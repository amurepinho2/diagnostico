{"ast":null,"code":"import pluralForms from '@tannin/plural-forms';\n\n/**\n * Tannin constructor options.\n *\n * @typedef {Object} TanninOptions\n *\n * @property {string}   [contextDelimiter] Joiner in string lookup with context.\n * @property {Function} [onMissingKey]     Callback to invoke when key missing.\n */\n\n/**\n * Domain metadata.\n *\n * @typedef {Object} TanninDomainMetadata\n *\n * @property {string}            [domain]       Domain name.\n * @property {string}            [lang]         Language code.\n * @property {(string|Function)} [plural_forms] Plural forms expression or\n *                                              function evaluator.\n */\n\n/**\n * Domain translation pair respectively representing the singular and plural\n * translation.\n *\n * @typedef {[string,string]} TanninTranslation\n */\n\n/**\n * Locale data domain. The key is used as reference for lookup, the value an\n * array of two string entries respectively representing the singular and plural\n * translation.\n *\n * @typedef {{[key:string]:TanninDomainMetadata|TanninTranslation,'':TanninDomainMetadata|TanninTranslation}} TanninLocaleDomain\n */\n\n/**\n * Jed-formatted locale data.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @typedef {{[domain:string]:TanninLocaleDomain}} TanninLocaleData\n */\n\n/**\n * Default Tannin constructor options.\n *\n * @type {TanninOptions}\n */\nvar DEFAULT_OPTIONS = {\n  contextDelimiter: '\\u0004',\n  onMissingKey: null\n};\n\n/**\n * Given a specific locale data's config `plural_forms` value, returns the\n * expression.\n *\n * @example\n *\n * ```\n * getPluralExpression( 'nplurals=2; plural=(n != 1);' ) === '(n != 1)'\n * ```\n *\n * @param {string} pf Locale data plural forms.\n *\n * @return {string} Plural forms expression.\n */\nfunction getPluralExpression(pf) {\n  var parts, i, part;\n  parts = pf.split(';');\n  for (i = 0; i < parts.length; i++) {\n    part = parts[i].trim();\n    if (part.indexOf('plural=') === 0) {\n      return part.substr(7);\n    }\n  }\n}\n\n/**\n * Tannin constructor.\n *\n * @class\n *\n * @param {TanninLocaleData} data      Jed-formatted locale data.\n * @param {TanninOptions}    [options] Tannin options.\n */\nexport default function Tannin(data, options) {\n  var key;\n\n  /**\n   * Jed-formatted locale data.\n   *\n   * @name Tannin#data\n   * @type {TanninLocaleData}\n   */\n  this.data = data;\n\n  /**\n   * Plural forms function cache, keyed by plural forms string.\n   *\n   * @name Tannin#pluralForms\n   * @type {Object<string,Function>}\n   */\n  this.pluralForms = {};\n\n  /**\n   * Effective options for instance, including defaults.\n   *\n   * @name Tannin#options\n   * @type {TanninOptions}\n   */\n  this.options = {};\n  for (key in DEFAULT_OPTIONS) {\n    this.options[key] = options !== undefined && key in options ? options[key] : DEFAULT_OPTIONS[key];\n  }\n}\n\n/**\n * Returns the plural form index for the given domain and value.\n *\n * @param {string} domain Domain on which to calculate plural form.\n * @param {number} n      Value for which plural form is to be calculated.\n *\n * @return {number} Plural form index.\n */\nTannin.prototype.getPluralForm = function (domain, n) {\n  var getPluralForm = this.pluralForms[domain],\n    config,\n    plural,\n    pf;\n  if (!getPluralForm) {\n    config = this.data[domain][''];\n    pf = config['Plural-Forms'] || config['plural-forms'] ||\n    // Ignore reason: As known, there's no way to document the empty\n    // string property on a key to guarantee this as metadata.\n    // @ts-ignore\n    config.plural_forms;\n    if (typeof pf !== 'function') {\n      plural = getPluralExpression(config['Plural-Forms'] || config['plural-forms'] ||\n      // Ignore reason: As known, there's no way to document the empty\n      // string property on a key to guarantee this as metadata.\n      // @ts-ignore\n      config.plural_forms);\n      pf = pluralForms(plural);\n    }\n    getPluralForm = this.pluralForms[domain] = pf;\n  }\n  return getPluralForm(n);\n};\n\n/**\n * Translate a string.\n *\n * @param {string}      domain   Translation domain.\n * @param {string|void} context  Context distinguishing terms of the same name.\n * @param {string}      singular Primary key for translation lookup.\n * @param {string=}     plural   Fallback value used for non-zero plural\n *                               form index.\n * @param {number=}     n        Value to use in calculating plural form.\n *\n * @return {string} Translated string.\n */\nTannin.prototype.dcnpgettext = function (domain, context, singular, plural, n) {\n  var index, key, entry;\n  if (n === undefined) {\n    // Default to singular.\n    index = 0;\n  } else {\n    // Find index by evaluating plural form for value.\n    index = this.getPluralForm(domain, n);\n  }\n  key = singular;\n\n  // If provided, context is prepended to key with delimiter.\n  if (context) {\n    key = context + this.options.contextDelimiter + singular;\n  }\n  entry = this.data[domain][key];\n\n  // Verify not only that entry exists, but that the intended index is within\n  // range and non-empty.\n  if (entry && entry[index]) {\n    return entry[index];\n  }\n  if (this.options.onMissingKey) {\n    this.options.onMissingKey(singular, domain);\n  }\n\n  // If entry not found, fall back to singular vs. plural with zero index\n  // representing the singular value.\n  return index === 0 ? singular : plural;\n};","map":{"version":3,"names":["pluralForms","DEFAULT_OPTIONS","contextDelimiter","onMissingKey","getPluralExpression","pf","parts","i","part","split","length","trim","indexOf","substr","Tannin","data","options","key","undefined","prototype","getPluralForm","domain","n","config","plural","plural_forms","dcnpgettext","context","singular","index","entry"],"sources":["/Users/amurepinho/Documents/GitHub/diagnostico/node_modules/tannin/index.js"],"sourcesContent":["import pluralForms from '@tannin/plural-forms';\n\n/**\n * Tannin constructor options.\n *\n * @typedef {Object} TanninOptions\n *\n * @property {string}   [contextDelimiter] Joiner in string lookup with context.\n * @property {Function} [onMissingKey]     Callback to invoke when key missing.\n */\n\n/**\n * Domain metadata.\n *\n * @typedef {Object} TanninDomainMetadata\n *\n * @property {string}            [domain]       Domain name.\n * @property {string}            [lang]         Language code.\n * @property {(string|Function)} [plural_forms] Plural forms expression or\n *                                              function evaluator.\n */\n\n/**\n * Domain translation pair respectively representing the singular and plural\n * translation.\n *\n * @typedef {[string,string]} TanninTranslation\n */\n\n/**\n * Locale data domain. The key is used as reference for lookup, the value an\n * array of two string entries respectively representing the singular and plural\n * translation.\n *\n * @typedef {{[key:string]:TanninDomainMetadata|TanninTranslation,'':TanninDomainMetadata|TanninTranslation}} TanninLocaleDomain\n */\n\n/**\n * Jed-formatted locale data.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @typedef {{[domain:string]:TanninLocaleDomain}} TanninLocaleData\n */\n\n/**\n * Default Tannin constructor options.\n *\n * @type {TanninOptions}\n */\nvar DEFAULT_OPTIONS = {\n\tcontextDelimiter: '\\u0004',\n\tonMissingKey: null,\n};\n\n/**\n * Given a specific locale data's config `plural_forms` value, returns the\n * expression.\n *\n * @example\n *\n * ```\n * getPluralExpression( 'nplurals=2; plural=(n != 1);' ) === '(n != 1)'\n * ```\n *\n * @param {string} pf Locale data plural forms.\n *\n * @return {string} Plural forms expression.\n */\nfunction getPluralExpression( pf ) {\n\tvar parts, i, part;\n\n\tparts = pf.split( ';' );\n\n\tfor ( i = 0; i < parts.length; i++ ) {\n\t\tpart = parts[ i ].trim();\n\t\tif ( part.indexOf( 'plural=' ) === 0 ) {\n\t\t\treturn part.substr( 7 );\n\t\t}\n\t}\n}\n\n/**\n * Tannin constructor.\n *\n * @class\n *\n * @param {TanninLocaleData} data      Jed-formatted locale data.\n * @param {TanninOptions}    [options] Tannin options.\n */\nexport default function Tannin( data, options ) {\n\tvar key;\n\n\t/**\n\t * Jed-formatted locale data.\n\t *\n\t * @name Tannin#data\n\t * @type {TanninLocaleData}\n\t */\n\tthis.data = data;\n\n\t/**\n\t * Plural forms function cache, keyed by plural forms string.\n\t *\n\t * @name Tannin#pluralForms\n\t * @type {Object<string,Function>}\n\t */\n\tthis.pluralForms = {};\n\n\t/**\n\t * Effective options for instance, including defaults.\n\t *\n\t * @name Tannin#options\n\t * @type {TanninOptions}\n\t */\n\tthis.options = {};\n\n\tfor ( key in DEFAULT_OPTIONS ) {\n\t\tthis.options[ key ] = options !== undefined && key in options\n\t\t\t? options[ key ]\n\t\t\t: DEFAULT_OPTIONS[ key ];\n\t}\n}\n\n/**\n * Returns the plural form index for the given domain and value.\n *\n * @param {string} domain Domain on which to calculate plural form.\n * @param {number} n      Value for which plural form is to be calculated.\n *\n * @return {number} Plural form index.\n */\nTannin.prototype.getPluralForm = function( domain, n ) {\n\tvar getPluralForm = this.pluralForms[ domain ],\n\t\tconfig, plural, pf;\n\n\tif ( ! getPluralForm ) {\n\t\tconfig = this.data[ domain ][ '' ];\n\n\t\tpf = (\n\t\t\tconfig[ 'Plural-Forms' ] ||\n\t\t\tconfig[ 'plural-forms' ] ||\n\t\t\t// Ignore reason: As known, there's no way to document the empty\n\t\t\t// string property on a key to guarantee this as metadata.\n\t\t\t// @ts-ignore\n\t\t\tconfig.plural_forms\n\t\t);\n\n\t\tif ( typeof pf !== 'function' ) {\n\t\t\tplural = getPluralExpression(\n\t\t\t\tconfig[ 'Plural-Forms' ] ||\n\t\t\t\tconfig[ 'plural-forms' ] ||\n\t\t\t\t// Ignore reason: As known, there's no way to document the empty\n\t\t\t\t// string property on a key to guarantee this as metadata.\n\t\t\t\t// @ts-ignore\n\t\t\t\tconfig.plural_forms\n\t\t\t);\n\n\t\t\tpf = pluralForms( plural );\n\t\t}\n\n\t\tgetPluralForm = this.pluralForms[ domain ] = pf;\n\t}\n\n\treturn getPluralForm( n );\n};\n\n/**\n * Translate a string.\n *\n * @param {string}      domain   Translation domain.\n * @param {string|void} context  Context distinguishing terms of the same name.\n * @param {string}      singular Primary key for translation lookup.\n * @param {string=}     plural   Fallback value used for non-zero plural\n *                               form index.\n * @param {number=}     n        Value to use in calculating plural form.\n *\n * @return {string} Translated string.\n */\nTannin.prototype.dcnpgettext = function( domain, context, singular, plural, n ) {\n\tvar index, key, entry;\n\n\tif ( n === undefined ) {\n\t\t// Default to singular.\n\t\tindex = 0;\n\t} else {\n\t\t// Find index by evaluating plural form for value.\n\t\tindex = this.getPluralForm( domain, n );\n\t}\n\n\tkey = singular;\n\n\t// If provided, context is prepended to key with delimiter.\n\tif ( context ) {\n\t\tkey = context + this.options.contextDelimiter + singular;\n\t}\n\n\tentry = this.data[ domain ][ key ];\n\n\t// Verify not only that entry exists, but that the intended index is within\n\t// range and non-empty.\n\tif ( entry && entry[ index ] ) {\n\t\treturn entry[ index ];\n\t}\n\n\tif ( this.options.onMissingKey ) {\n\t\tthis.options.onMissingKey( singular, domain );\n\t}\n\n\t// If entry not found, fall back to singular vs. plural with zero index\n\t// representing the singular value.\n\treturn index === 0 ? singular : plural;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}