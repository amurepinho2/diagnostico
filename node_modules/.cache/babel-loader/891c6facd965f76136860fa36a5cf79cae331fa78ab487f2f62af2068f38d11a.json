{"ast":null,"code":"\"use strict\";\n\n/**\r\n * Zenscroll 4.0.2\r\n * https://github.com/zengabor/zenscroll/\r\n *\r\n * Copyright 2015–2018 Gabor Lenard\r\n *\r\n * This is free and unencumbered software released into the public domain.\r\n *\r\n * Anyone is free to copy, modify, publish, use, compile, sell, or\r\n * distribute this software, either in source code form or as a compiled\r\n * binary, for any purpose, commercial or non-commercial, and by any\r\n * means.\r\n *\r\n * In jurisdictions that recognize copyright laws, the author or authors\r\n * of this software dedicate any and all copyright interest in the\r\n * software to the public domain. We make this dedication for the benefit\r\n * of the public at large and to the detriment of our heirs and\r\n * successors. We intend this dedication to be an overt act of\r\n * relinquishment in perpetuity of all present and future rights to this\r\n * software under copyright law.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\r\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * For more information, please refer to <http://unlicense.org>\r\n *\r\n */\n\n/*jshint devel:true, asi:true */\n\n/*global define, module */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory());\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory();\n  } else {\n    (function install() {\n      // To make sure Zenscroll can be referenced from the header, before `body` is available\n      if (document && document.body) {\n        root.zenscroll = factory();\n      } else {\n        // retry 9ms later\n        setTimeout(install, 9);\n      }\n    })();\n  }\n})(void 0, function () {\n  'use strict';\n\n  // Detect if the browser already supports native smooth scrolling (e.g., Firefox 36+ and Chrome 49+) and it is enabled:\n  const isNativeSmoothScrollEnabledOn = function (elem) {\n    return elem && 'getComputedStyle' in window && window.getComputedStyle(elem)['scroll-behavior'] === 'smooth';\n  };\n\n  // Exit if it’s not a browser environment:\n  if (typeof window === 'undefined' || !('document' in window)) {\n    return {};\n  }\n  const makeScroller = function (container, defaultDuration, edgeOffset) {\n    // Use defaults if not provided\n    defaultDuration = defaultDuration || 999; //ms\n    if (!edgeOffset && edgeOffset !== 0) {\n      // When scrolling, this amount of distance is kept from the edges of the container:\n      edgeOffset = 9; //px\n    }\n\n    // Handling the life-cycle of the scroller\n    let scrollTimeoutId;\n    const setScrollTimeoutId = function (newValue) {\n      scrollTimeoutId = newValue;\n    };\n\n    /**\r\n     * Stop the current smooth scroll operation immediately\r\n     */\n    const stopScroll = function () {\n      clearTimeout(scrollTimeoutId);\n      setScrollTimeoutId(0);\n    };\n    const getTopWithEdgeOffset = function (elem) {\n      return Math.max(0, container.getTopOf(elem) - edgeOffset);\n    };\n\n    /**\r\n     * Scrolls to a specific vertical position in the document.\r\n     *\r\n     * @param {targetY}  The        vertical position within the document.\r\n     * @param {duration} Optionally the duration of the scroll operation.\r\n     *                              If not provided the default duration is used.\r\n     * @param {onDone}   An         optional callback function to be invoked once the scroll finished.\r\n     * @param            targetY\r\n     * @param            duration\r\n     * @param            onDone\r\n     */\n    const scrollToY = function (targetY, duration, onDone) {\n      stopScroll();\n      if (duration === 0 || duration && duration < 0 || isNativeSmoothScrollEnabledOn(container.body)) {\n        container.toY(targetY);\n        if (onDone) {\n          onDone();\n        }\n      } else {\n        const startY = container.getY();\n        const distance = Math.max(0, targetY) - startY;\n        const startTime = new Date().getTime();\n        duration = duration || Math.min(Math.abs(distance), defaultDuration);\n        (function loopScroll() {\n          setScrollTimeoutId(setTimeout(function () {\n            // Calculate percentage:\n            const p = Math.min(1, (new Date().getTime() - startTime) / duration);\n            // Calculate the absolute vertical position:\n            const y = Math.max(0, Math.floor(startY + distance * (p < 0.5 ? 2 * p * p : p * (4 - p * 2) - 1)));\n            container.toY(y);\n            if (p < 1 && container.getHeight() + y < container.body.scrollHeight) {\n              loopScroll();\n            } else {\n              setTimeout(stopScroll, 99); // with cooldown time\n              if (onDone) {\n                onDone();\n              }\n            }\n          }, 9));\n        })();\n      }\n    };\n\n    /**\r\n     * Scrolls to the top of a specific element.\r\n     *\r\n     * @param {elem}     The        element to scroll to.\r\n     * @param {duration} Optionally the duration of the scroll operation.\r\n     * @param {onDone}   An         optional callback function to be invoked once the scroll finished.\r\n     * @param            elem\r\n     * @param            duration\r\n     * @param            onDone\r\n     */\n    const scrollToElem = function (elem, duration, onDone) {\n      scrollToY(getTopWithEdgeOffset(elem), duration, onDone);\n    };\n\n    /**\r\n     * Scrolls an element into view if necessary.\r\n     *\r\n     * @param {elem}     The        element.\r\n     * @param {duration} Optionally the duration of the scroll operation.\r\n     * @param {onDone}   An         optional callback function to be invoked once the scroll finished.\r\n     * @param            elem\r\n     * @param            duration\r\n     * @param            onDone\r\n     */\n    const scrollIntoView = function (elem, duration, onDone) {\n      const elemHeight = elem.getBoundingClientRect().height;\n      const elemBottom = container.getTopOf(elem) + elemHeight;\n      const containerHeight = container.getHeight();\n      const y = container.getY();\n      const containerBottom = y + containerHeight;\n      if (getTopWithEdgeOffset(elem) < y || elemHeight + edgeOffset > containerHeight) {\n        // Element is clipped at top or is higher than screen.\n        scrollToElem(elem, duration, onDone);\n      } else if (elemBottom + edgeOffset > containerBottom) {\n        // Element is clipped at the bottom.\n        scrollToY(elemBottom - containerHeight + edgeOffset, duration, onDone);\n      } else if (onDone) {\n        onDone();\n      }\n    };\n\n    /**\r\n     * Scrolls to the center of an element.\r\n     *\r\n     * @param {elem}     The        element.\r\n     * @param {duration} Optionally the duration of the scroll operation.\r\n     * @param {offset}   Optionally the offset of the top of the element from the center of the screen.\r\n     *                              A value of 0 is ignored.\r\n     * @param {onDone}   An         optional callback function to be invoked once the scroll finished.\r\n     * @param            elem\r\n     * @param            duration\r\n     * @param            offset\r\n     * @param            onDone\r\n     */\n    const scrollToCenterOf = function (elem, duration, offset, onDone) {\n      scrollToY(Math.max(0, container.getTopOf(elem) - container.getHeight() / 2 + (offset || elem.getBoundingClientRect().height / 2)), duration, onDone);\n    };\n\n    /**\r\n     * Changes default settings for this scroller.\r\n     *\r\n     * @param {newDefaultDuration} Optionally         a new value for default duration, used for each scroll method by default.\r\n     *                                                Ignored if null or undefined.\r\n     * @param {newEdgeOffset}      Optionally         a new value for the edge offset, used by each scroll method by default. Ignored if null or undefined.\r\n     * @param                      newDefaultDuration\r\n     * @param                      newEdgeOffset\r\n     * @return An object with the current values.\r\n     */\n    const setup = function (newDefaultDuration, newEdgeOffset) {\n      if (newDefaultDuration === 0 || newDefaultDuration) {\n        defaultDuration = newDefaultDuration;\n      }\n      if (newEdgeOffset === 0 || newEdgeOffset) {\n        edgeOffset = newEdgeOffset;\n      }\n      return {\n        defaultDuration,\n        edgeOffset\n      };\n    };\n    return {\n      setup,\n      to: scrollToElem,\n      toY: scrollToY,\n      intoView: scrollIntoView,\n      center: scrollToCenterOf,\n      stop: stopScroll,\n      moving() {\n        return !!scrollTimeoutId;\n      },\n      getY: container.getY,\n      getTopOf: container.getTopOf\n    };\n  };\n  const docElem = document.documentElement;\n  const getDocY = function () {\n    return window.scrollY || docElem.scrollTop;\n  };\n\n  // Create a scroller for the document:\n  const zenscroll = makeScroller({\n    body: document.scrollingElement || document.body,\n    toY(y) {\n      window.scrollTo(0, y);\n    },\n    getY: getDocY,\n    getHeight() {\n      return window.innerHeight || docElem.clientHeight;\n    },\n    getTopOf(elem) {\n      return elem.getBoundingClientRect().top + getDocY() - docElem.offsetTop;\n    }\n  });\n\n  /**\r\n   * Creates a scroller from the provided container element (e.g., a DIV)\r\n   *\r\n   * @param {scrollContainer} The             vertical position within the document.\r\n   * @param {defaultDuration} Optionally      a value for default duration, used for each scroll method by default.\r\n   *                                          Ignored if 0 or null or undefined.\r\n   * @param {edgeOffset}      Optionally      a value for the edge offset, used by each scroll method by default.\r\n   *                                          Ignored if null or undefined.\r\n   * @param                   scrollContainer\r\n   * @param                   defaultDuration\r\n   * @param                   edgeOffset\r\n   * @return A scroller object, similar to `zenscroll` but controlling the provided element.\r\n   */\n  zenscroll.createScroller = function (scrollContainer, defaultDuration, edgeOffset) {\n    return makeScroller({\n      body: scrollContainer,\n      toY(y) {\n        scrollContainer.scrollTop = y;\n      },\n      getY() {\n        return scrollContainer.scrollTop;\n      },\n      getHeight() {\n        return Math.min(scrollContainer.clientHeight, window.innerHeight || docElem.clientHeight);\n      },\n      getTopOf(elem) {\n        return elem.offsetTop;\n      }\n    }, defaultDuration, edgeOffset);\n  };\n\n  // Automatic link-smoothing on achors\n  // Exclude IE8- or when native is enabled or Zenscroll auto- is disabled\n  if ('addEventListener' in window && !window.noZensmooth && !isNativeSmoothScrollEnabledOn(document.body)) {\n    const isHistorySupported = 'history' in window && 'pushState' in history;\n    const isScrollRestorationSupported = isHistorySupported && 'scrollRestoration' in history;\n\n    // On first load & refresh make sure the browser restores the position first\n    if (isScrollRestorationSupported) {\n      history.scrollRestoration = 'auto';\n    }\n    window.addEventListener('load', function () {\n      if (isScrollRestorationSupported) {\n        // Set it to manual\n        setTimeout(function () {\n          history.scrollRestoration = 'manual';\n        }, 9);\n        window.addEventListener('popstate', function (event) {\n          if (event.state && 'zenscrollY' in event.state) {\n            zenscroll.toY(event.state.zenscrollY);\n          }\n        }, false);\n      }\n\n      // Add edge offset on first load if necessary\n      // This may not work on IE (or older computer?) as it requires more timeout, around 100 ms\n      if (window.location.hash) {\n        setTimeout(function () {\n          // Adjustment is only needed if there is an edge offset:\n          const edgeOffset = zenscroll.setup().edgeOffset;\n          if (edgeOffset) {\n            const targetElem = document.getElementById(window.location.href.split('#')[1]);\n            if (targetElem) {\n              const targetY = Math.max(0, zenscroll.getTopOf(targetElem) - edgeOffset);\n              const diff = zenscroll.getY() - targetY;\n              // Only do the adjustment if the browser is very close to the element:\n              if (0 <= diff && diff < 9) {\n                window.scrollTo(0, targetY);\n              }\n            }\n          }\n        }, 9);\n      }\n    }, false);\n\n    // Handling clicks on anchors\n    const RE_noZensmooth = new RegExp('(^|\\\\s)noZensmooth(\\\\s|$)');\n    window.addEventListener('click', function (event) {\n      let anchor = event.target;\n      while (anchor && anchor.tagName !== 'A') {\n        anchor = anchor.parentNode;\n      }\n      // Let the browser handle the click if it wasn't with the primary button, or with some modifier keys:\n      if (!anchor || event.which !== 1 || event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n        return;\n      }\n      // Save the current scrolling position so it can be used for scroll restoration:\n      if (isScrollRestorationSupported) {\n        const historyState = history.state && typeof history.state === 'object' ? history.state : {};\n        historyState.zenscrollY = zenscroll.getY();\n        try {\n          history.replaceState(historyState, '');\n        } catch (e) {\n          // Avoid the Chrome Security exception on file protocol, e.g., file://index.html\n        }\n      }\n      // Find the referenced ID:\n      const href = anchor.getAttribute('href') || '';\n      if (href.indexOf('#') === 0 && !RE_noZensmooth.test(anchor.className)) {\n        let targetY = 0;\n        const targetElem = document.getElementById(href.substring(1));\n        if (href !== '#') {\n          if (!targetElem) {\n            // Let the browser handle the click if the target ID is not found.\n            return;\n          }\n          targetY = zenscroll.getTopOf(targetElem);\n        }\n        event.preventDefault();\n        // By default trigger the browser's `hashchange` event...\n        let onDone = function () {\n          window.location = href;\n        };\n        // ...unless there is an edge offset specified\n        const edgeOffset = zenscroll.setup().edgeOffset;\n        if (edgeOffset) {\n          targetY = Math.max(0, targetY - edgeOffset);\n          if (isHistorySupported) {\n            onDone = function () {\n              history.pushState({}, '', href);\n            };\n          }\n        }\n        zenscroll.toY(targetY, null, onDone);\n      }\n    }, false);\n  }\n  return zenscroll;\n});","map":{"version":3,"names":["root","factory","define","amd","module","exports","install","document","body","zenscroll","setTimeout","isNativeSmoothScrollEnabledOn","elem","window","getComputedStyle","makeScroller","container","defaultDuration","edgeOffset","scrollTimeoutId","setScrollTimeoutId","newValue","stopScroll","clearTimeout","getTopWithEdgeOffset","Math","max","getTopOf","scrollToY","targetY","duration","onDone","toY","startY","getY","distance","startTime","Date","getTime","min","abs","loopScroll","p","y","floor","getHeight","scrollHeight","scrollToElem","scrollIntoView","elemHeight","getBoundingClientRect","height","elemBottom","containerHeight","containerBottom","scrollToCenterOf","offset","setup","newDefaultDuration","newEdgeOffset","to","intoView","center","stop","moving","docElem","documentElement","getDocY","scrollY","scrollTop","scrollingElement","scrollTo","innerHeight","clientHeight","top","offsetTop","createScroller","scrollContainer","noZensmooth","isHistorySupported","history","isScrollRestorationSupported","scrollRestoration","addEventListener","event","state","zenscrollY","location","hash","targetElem","getElementById","href","split","diff","RE_noZensmooth","RegExp","anchor","target","tagName","parentNode","which","shiftKey","metaKey","ctrlKey","altKey","historyState","replaceState","e","getAttribute","indexOf","test","className","substring","preventDefault","pushState"],"sources":["/Users/amurepinho/Documents/GitHub/diagnostico/node_modules/@quillforms/blocklib-group-block/build/renderer/@quillforms/blocklib-group-block/src/renderer/zen-scroll.js"],"sourcesContent":["/**\r\n * Zenscroll 4.0.2\r\n * https://github.com/zengabor/zenscroll/\r\n *\r\n * Copyright 2015–2018 Gabor Lenard\r\n *\r\n * This is free and unencumbered software released into the public domain.\r\n *\r\n * Anyone is free to copy, modify, publish, use, compile, sell, or\r\n * distribute this software, either in source code form or as a compiled\r\n * binary, for any purpose, commercial or non-commercial, and by any\r\n * means.\r\n *\r\n * In jurisdictions that recognize copyright laws, the author or authors\r\n * of this software dedicate any and all copyright interest in the\r\n * software to the public domain. We make this dedication for the benefit\r\n * of the public at large and to the detriment of our heirs and\r\n * successors. We intend this dedication to be an overt act of\r\n * relinquishment in perpetuity of all present and future rights to this\r\n * software under copyright law.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\r\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * For more information, please refer to <http://unlicense.org>\r\n *\r\n */\r\n\r\n/*jshint devel:true, asi:true */\r\n\r\n/*global define, module */\r\n\r\n( function ( root, factory ) {\r\n\tif ( typeof define === 'function' && define.amd ) {\r\n\t\tdefine( [], factory() );\r\n\t} else if ( typeof module === 'object' && module.exports ) {\r\n\t\tmodule.exports = factory();\r\n\t} else {\r\n\t\t( function install() {\r\n\t\t\t// To make sure Zenscroll can be referenced from the header, before `body` is available\r\n\t\t\tif ( document && document.body ) {\r\n\t\t\t\troot.zenscroll = factory();\r\n\t\t\t} else {\r\n\t\t\t\t// retry 9ms later\r\n\t\t\t\tsetTimeout( install, 9 );\r\n\t\t\t}\r\n\t\t} )();\r\n\t}\r\n} )( this, function () {\r\n\t'use strict';\r\n\r\n\t// Detect if the browser already supports native smooth scrolling (e.g., Firefox 36+ and Chrome 49+) and it is enabled:\r\n\tconst isNativeSmoothScrollEnabledOn = function ( elem ) {\r\n\t\treturn (\r\n\t\t\telem &&\r\n\t\t\t'getComputedStyle' in window &&\r\n\t\t\twindow.getComputedStyle( elem )[ 'scroll-behavior' ] === 'smooth'\r\n\t\t);\r\n\t};\r\n\r\n\t// Exit if it’s not a browser environment:\r\n\tif ( typeof window === 'undefined' || ! ( 'document' in window ) ) {\r\n\t\treturn {};\r\n\t}\r\n\r\n\tconst makeScroller = function ( container, defaultDuration, edgeOffset ) {\r\n\t\t// Use defaults if not provided\r\n\t\tdefaultDuration = defaultDuration || 999; //ms\r\n\t\tif ( ! edgeOffset && edgeOffset !== 0 ) {\r\n\t\t\t// When scrolling, this amount of distance is kept from the edges of the container:\r\n\t\t\tedgeOffset = 9; //px\r\n\t\t}\r\n\r\n\t\t// Handling the life-cycle of the scroller\r\n\t\tlet scrollTimeoutId;\r\n\t\tconst setScrollTimeoutId = function ( newValue ) {\r\n\t\t\tscrollTimeoutId = newValue;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Stop the current smooth scroll operation immediately\r\n\t\t */\r\n\t\tconst stopScroll = function () {\r\n\t\t\tclearTimeout( scrollTimeoutId );\r\n\t\t\tsetScrollTimeoutId( 0 );\r\n\t\t};\r\n\r\n\t\tconst getTopWithEdgeOffset = function ( elem ) {\r\n\t\t\treturn Math.max( 0, container.getTopOf( elem ) - edgeOffset );\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Scrolls to a specific vertical position in the document.\r\n\t\t *\r\n\t\t * @param {targetY}  The        vertical position within the document.\r\n\t\t * @param {duration} Optionally the duration of the scroll operation.\r\n\t\t *                              If not provided the default duration is used.\r\n\t\t * @param {onDone}   An         optional callback function to be invoked once the scroll finished.\r\n\t\t * @param            targetY\r\n\t\t * @param            duration\r\n\t\t * @param            onDone\r\n\t\t */\r\n\t\tconst scrollToY = function ( targetY, duration, onDone ) {\r\n\t\t\tstopScroll();\r\n\t\t\tif (\r\n\t\t\t\tduration === 0 ||\r\n\t\t\t\t( duration && duration < 0 ) ||\r\n\t\t\t\tisNativeSmoothScrollEnabledOn( container.body )\r\n\t\t\t) {\r\n\t\t\t\tcontainer.toY( targetY );\r\n\t\t\t\tif ( onDone ) {\r\n\t\t\t\t\tonDone();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst startY = container.getY();\r\n\t\t\t\tconst distance = Math.max( 0, targetY ) - startY;\r\n\t\t\t\tconst startTime = new Date().getTime();\r\n\t\t\t\tduration =\r\n\t\t\t\t\tduration ||\r\n\t\t\t\t\tMath.min( Math.abs( distance ), defaultDuration );\r\n\t\t\t\t( function loopScroll() {\r\n\t\t\t\t\tsetScrollTimeoutId(\r\n\t\t\t\t\t\tsetTimeout( function () {\r\n\t\t\t\t\t\t\t// Calculate percentage:\r\n\t\t\t\t\t\t\tconst p = Math.min(\r\n\t\t\t\t\t\t\t\t1,\r\n\t\t\t\t\t\t\t\t( new Date().getTime() - startTime ) / duration\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t// Calculate the absolute vertical position:\r\n\t\t\t\t\t\t\tconst y = Math.max(\r\n\t\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t\tMath.floor(\r\n\t\t\t\t\t\t\t\t\tstartY +\r\n\t\t\t\t\t\t\t\t\t\tdistance *\r\n\t\t\t\t\t\t\t\t\t\t\t( p < 0.5\r\n\t\t\t\t\t\t\t\t\t\t\t\t? 2 * p * p\r\n\t\t\t\t\t\t\t\t\t\t\t\t: p * ( 4 - p * 2 ) - 1 )\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontainer.toY( y );\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tp < 1 &&\r\n\t\t\t\t\t\t\t\tcontainer.getHeight() + y <\r\n\t\t\t\t\t\t\t\t\tcontainer.body.scrollHeight\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tloopScroll();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tsetTimeout( stopScroll, 99 ); // with cooldown time\r\n\t\t\t\t\t\t\t\tif ( onDone ) {\r\n\t\t\t\t\t\t\t\t\tonDone();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, 9 )\r\n\t\t\t\t\t);\r\n\t\t\t\t} )();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Scrolls to the top of a specific element.\r\n\t\t *\r\n\t\t * @param {elem}     The        element to scroll to.\r\n\t\t * @param {duration} Optionally the duration of the scroll operation.\r\n\t\t * @param {onDone}   An         optional callback function to be invoked once the scroll finished.\r\n\t\t * @param            elem\r\n\t\t * @param            duration\r\n\t\t * @param            onDone\r\n\t\t */\r\n\t\tconst scrollToElem = function ( elem, duration, onDone ) {\r\n\t\t\tscrollToY( getTopWithEdgeOffset( elem ), duration, onDone );\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Scrolls an element into view if necessary.\r\n\t\t *\r\n\t\t * @param {elem}     The        element.\r\n\t\t * @param {duration} Optionally the duration of the scroll operation.\r\n\t\t * @param {onDone}   An         optional callback function to be invoked once the scroll finished.\r\n\t\t * @param            elem\r\n\t\t * @param            duration\r\n\t\t * @param            onDone\r\n\t\t */\r\n\t\tconst scrollIntoView = function ( elem, duration, onDone ) {\r\n\t\t\tconst elemHeight = elem.getBoundingClientRect().height;\r\n\t\t\tconst elemBottom = container.getTopOf( elem ) + elemHeight;\r\n\t\t\tconst containerHeight = container.getHeight();\r\n\t\t\tconst y = container.getY();\r\n\t\t\tconst containerBottom = y + containerHeight;\r\n\t\t\tif (\r\n\t\t\t\tgetTopWithEdgeOffset( elem ) < y ||\r\n\t\t\t\telemHeight + edgeOffset > containerHeight\r\n\t\t\t) {\r\n\t\t\t\t// Element is clipped at top or is higher than screen.\r\n\t\t\t\tscrollToElem( elem, duration, onDone );\r\n\t\t\t} else if ( elemBottom + edgeOffset > containerBottom ) {\r\n\t\t\t\t// Element is clipped at the bottom.\r\n\t\t\t\tscrollToY(\r\n\t\t\t\t\telemBottom - containerHeight + edgeOffset,\r\n\t\t\t\t\tduration,\r\n\t\t\t\t\tonDone\r\n\t\t\t\t);\r\n\t\t\t} else if ( onDone ) {\r\n\t\t\t\tonDone();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Scrolls to the center of an element.\r\n\t\t *\r\n\t\t * @param {elem}     The        element.\r\n\t\t * @param {duration} Optionally the duration of the scroll operation.\r\n\t\t * @param {offset}   Optionally the offset of the top of the element from the center of the screen.\r\n\t\t *                              A value of 0 is ignored.\r\n\t\t * @param {onDone}   An         optional callback function to be invoked once the scroll finished.\r\n\t\t * @param            elem\r\n\t\t * @param            duration\r\n\t\t * @param            offset\r\n\t\t * @param            onDone\r\n\t\t */\r\n\t\tconst scrollToCenterOf = function ( elem, duration, offset, onDone ) {\r\n\t\t\tscrollToY(\r\n\t\t\t\tMath.max(\r\n\t\t\t\t\t0,\r\n\t\t\t\t\tcontainer.getTopOf( elem ) -\r\n\t\t\t\t\t\tcontainer.getHeight() / 2 +\r\n\t\t\t\t\t\t( offset || elem.getBoundingClientRect().height / 2 )\r\n\t\t\t\t),\r\n\t\t\t\tduration,\r\n\t\t\t\tonDone\r\n\t\t\t);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Changes default settings for this scroller.\r\n\t\t *\r\n\t\t * @param {newDefaultDuration} Optionally         a new value for default duration, used for each scroll method by default.\r\n\t\t *                                                Ignored if null or undefined.\r\n\t\t * @param {newEdgeOffset}      Optionally         a new value for the edge offset, used by each scroll method by default. Ignored if null or undefined.\r\n\t\t * @param                      newDefaultDuration\r\n\t\t * @param                      newEdgeOffset\r\n\t\t * @return An object with the current values.\r\n\t\t */\r\n\t\tconst setup = function ( newDefaultDuration, newEdgeOffset ) {\r\n\t\t\tif ( newDefaultDuration === 0 || newDefaultDuration ) {\r\n\t\t\t\tdefaultDuration = newDefaultDuration;\r\n\t\t\t}\r\n\t\t\tif ( newEdgeOffset === 0 || newEdgeOffset ) {\r\n\t\t\t\tedgeOffset = newEdgeOffset;\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tdefaultDuration,\r\n\t\t\t\tedgeOffset,\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tsetup,\r\n\t\t\tto: scrollToElem,\r\n\t\t\ttoY: scrollToY,\r\n\t\t\tintoView: scrollIntoView,\r\n\t\t\tcenter: scrollToCenterOf,\r\n\t\t\tstop: stopScroll,\r\n\t\t\tmoving() {\r\n\t\t\t\treturn !! scrollTimeoutId;\r\n\t\t\t},\r\n\t\t\tgetY: container.getY,\r\n\t\t\tgetTopOf: container.getTopOf,\r\n\t\t};\r\n\t};\r\n\r\n\tconst docElem = document.documentElement;\r\n\tconst getDocY = function () {\r\n\t\treturn window.scrollY || docElem.scrollTop;\r\n\t};\r\n\r\n\t// Create a scroller for the document:\r\n\tconst zenscroll = makeScroller( {\r\n\t\tbody: document.scrollingElement || document.body,\r\n\t\ttoY( y ) {\r\n\t\t\twindow.scrollTo( 0, y );\r\n\t\t},\r\n\t\tgetY: getDocY,\r\n\t\tgetHeight() {\r\n\t\t\treturn window.innerHeight || docElem.clientHeight;\r\n\t\t},\r\n\t\tgetTopOf( elem ) {\r\n\t\t\treturn (\r\n\t\t\t\telem.getBoundingClientRect().top + getDocY() - docElem.offsetTop\r\n\t\t\t);\r\n\t\t},\r\n\t} );\r\n\r\n\t/**\r\n\t * Creates a scroller from the provided container element (e.g., a DIV)\r\n\t *\r\n\t * @param {scrollContainer} The             vertical position within the document.\r\n\t * @param {defaultDuration} Optionally      a value for default duration, used for each scroll method by default.\r\n\t *                                          Ignored if 0 or null or undefined.\r\n\t * @param {edgeOffset}      Optionally      a value for the edge offset, used by each scroll method by default.\r\n\t *                                          Ignored if null or undefined.\r\n\t * @param                   scrollContainer\r\n\t * @param                   defaultDuration\r\n\t * @param                   edgeOffset\r\n\t * @return A scroller object, similar to `zenscroll` but controlling the provided element.\r\n\t */\r\n\tzenscroll.createScroller = function (\r\n\t\tscrollContainer,\r\n\t\tdefaultDuration,\r\n\t\tedgeOffset\r\n\t) {\r\n\t\treturn makeScroller(\r\n\t\t\t{\r\n\t\t\t\tbody: scrollContainer,\r\n\t\t\t\ttoY( y ) {\r\n\t\t\t\t\tscrollContainer.scrollTop = y;\r\n\t\t\t\t},\r\n\t\t\t\tgetY() {\r\n\t\t\t\t\treturn scrollContainer.scrollTop;\r\n\t\t\t\t},\r\n\t\t\t\tgetHeight() {\r\n\t\t\t\t\treturn Math.min(\r\n\t\t\t\t\t\tscrollContainer.clientHeight,\r\n\t\t\t\t\t\twindow.innerHeight || docElem.clientHeight\r\n\t\t\t\t\t);\r\n\t\t\t\t},\r\n\t\t\t\tgetTopOf( elem ) {\r\n\t\t\t\t\treturn elem.offsetTop;\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tdefaultDuration,\r\n\t\t\tedgeOffset\r\n\t\t);\r\n\t};\r\n\r\n\t// Automatic link-smoothing on achors\r\n\t// Exclude IE8- or when native is enabled or Zenscroll auto- is disabled\r\n\tif (\r\n\t\t'addEventListener' in window &&\r\n\t\t! window.noZensmooth &&\r\n\t\t! isNativeSmoothScrollEnabledOn( document.body )\r\n\t) {\r\n\t\tconst isHistorySupported =\r\n\t\t\t'history' in window && 'pushState' in history;\r\n\t\tconst isScrollRestorationSupported =\r\n\t\t\tisHistorySupported && 'scrollRestoration' in history;\r\n\r\n\t\t// On first load & refresh make sure the browser restores the position first\r\n\t\tif ( isScrollRestorationSupported ) {\r\n\t\t\thistory.scrollRestoration = 'auto';\r\n\t\t}\r\n\r\n\t\twindow.addEventListener(\r\n\t\t\t'load',\r\n\t\t\tfunction () {\r\n\t\t\t\tif ( isScrollRestorationSupported ) {\r\n\t\t\t\t\t// Set it to manual\r\n\t\t\t\t\tsetTimeout( function () {\r\n\t\t\t\t\t\thistory.scrollRestoration = 'manual';\r\n\t\t\t\t\t}, 9 );\r\n\t\t\t\t\twindow.addEventListener(\r\n\t\t\t\t\t\t'popstate',\r\n\t\t\t\t\t\tfunction ( event ) {\r\n\t\t\t\t\t\t\tif ( event.state && 'zenscrollY' in event.state ) {\r\n\t\t\t\t\t\t\t\tzenscroll.toY( event.state.zenscrollY );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tfalse\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Add edge offset on first load if necessary\r\n\t\t\t\t// This may not work on IE (or older computer?) as it requires more timeout, around 100 ms\r\n\t\t\t\tif ( window.location.hash ) {\r\n\t\t\t\t\tsetTimeout( function () {\r\n\t\t\t\t\t\t// Adjustment is only needed if there is an edge offset:\r\n\t\t\t\t\t\tconst edgeOffset = zenscroll.setup().edgeOffset;\r\n\t\t\t\t\t\tif ( edgeOffset ) {\r\n\t\t\t\t\t\t\tconst targetElem = document.getElementById(\r\n\t\t\t\t\t\t\t\twindow.location.href.split( '#' )[ 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tif ( targetElem ) {\r\n\t\t\t\t\t\t\t\tconst targetY = Math.max(\r\n\t\t\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t\t\tzenscroll.getTopOf( targetElem ) -\r\n\t\t\t\t\t\t\t\t\t\tedgeOffset\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\tconst diff = zenscroll.getY() - targetY;\r\n\t\t\t\t\t\t\t\t// Only do the adjustment if the browser is very close to the element:\r\n\t\t\t\t\t\t\t\tif ( 0 <= diff && diff < 9 ) {\r\n\t\t\t\t\t\t\t\t\twindow.scrollTo( 0, targetY );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, 9 );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfalse\r\n\t\t);\r\n\r\n\t\t// Handling clicks on anchors\r\n\t\tconst RE_noZensmooth = new RegExp( '(^|\\\\s)noZensmooth(\\\\s|$)' );\r\n\t\twindow.addEventListener(\r\n\t\t\t'click',\r\n\t\t\tfunction ( event ) {\r\n\t\t\t\tlet anchor = event.target;\r\n\t\t\t\twhile ( anchor && anchor.tagName !== 'A' ) {\r\n\t\t\t\t\tanchor = anchor.parentNode;\r\n\t\t\t\t}\r\n\t\t\t\t// Let the browser handle the click if it wasn't with the primary button, or with some modifier keys:\r\n\t\t\t\tif (\r\n\t\t\t\t\t! anchor ||\r\n\t\t\t\t\tevent.which !== 1 ||\r\n\t\t\t\t\tevent.shiftKey ||\r\n\t\t\t\t\tevent.metaKey ||\r\n\t\t\t\t\tevent.ctrlKey ||\r\n\t\t\t\t\tevent.altKey\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t// Save the current scrolling position so it can be used for scroll restoration:\r\n\t\t\t\tif ( isScrollRestorationSupported ) {\r\n\t\t\t\t\tconst historyState =\r\n\t\t\t\t\t\thistory.state && typeof history.state === 'object'\r\n\t\t\t\t\t\t\t? history.state\r\n\t\t\t\t\t\t\t: {};\r\n\t\t\t\t\thistoryState.zenscrollY = zenscroll.getY();\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\thistory.replaceState( historyState, '' );\r\n\t\t\t\t\t} catch ( e ) {\r\n\t\t\t\t\t\t// Avoid the Chrome Security exception on file protocol, e.g., file://index.html\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Find the referenced ID:\r\n\t\t\t\tconst href = anchor.getAttribute( 'href' ) || '';\r\n\t\t\t\tif (\r\n\t\t\t\t\thref.indexOf( '#' ) === 0 &&\r\n\t\t\t\t\t! RE_noZensmooth.test( anchor.className )\r\n\t\t\t\t) {\r\n\t\t\t\t\tlet targetY = 0;\r\n\t\t\t\t\tconst targetElem = document.getElementById(\r\n\t\t\t\t\t\thref.substring( 1 )\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif ( href !== '#' ) {\r\n\t\t\t\t\t\tif ( ! targetElem ) {\r\n\t\t\t\t\t\t\t// Let the browser handle the click if the target ID is not found.\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttargetY = zenscroll.getTopOf( targetElem );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\t// By default trigger the browser's `hashchange` event...\r\n\t\t\t\t\tlet onDone = function () {\r\n\t\t\t\t\t\twindow.location = href;\r\n\t\t\t\t\t};\r\n\t\t\t\t\t// ...unless there is an edge offset specified\r\n\t\t\t\t\tconst edgeOffset = zenscroll.setup().edgeOffset;\r\n\t\t\t\t\tif ( edgeOffset ) {\r\n\t\t\t\t\t\ttargetY = Math.max( 0, targetY - edgeOffset );\r\n\t\t\t\t\t\tif ( isHistorySupported ) {\r\n\t\t\t\t\t\t\tonDone = function () {\r\n\t\t\t\t\t\t\t\thistory.pushState( {}, '', href );\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tzenscroll.toY( targetY, null, onDone );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfalse\r\n\t\t);\r\n\t}\r\n\r\n\treturn zenscroll;\r\n} );\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}