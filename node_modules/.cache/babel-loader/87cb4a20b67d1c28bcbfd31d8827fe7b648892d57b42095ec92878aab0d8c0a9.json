{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createAutoCorrectedDatePipe;\nconst maxValueMonth = [31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst formatOrder = ['yyyy', 'yy', 'mm', 'dd', 'HH', 'MM', 'SS'];\nfunction createAutoCorrectedDatePipe(dateFormat = 'mm dd yyyy', {\n  minYear = 1,\n  maxYear = 9999\n} = {}) {\n  const dateFormatArray = dateFormat.split(/[^dmyHMS]+/).sort((a, b) => formatOrder.indexOf(a) - formatOrder.indexOf(b));\n  return function (conformedValue) {\n    const indexesOfPipedChars = [];\n    const maxValue = {\n      dd: 31,\n      mm: 12,\n      yy: 99,\n      yyyy: maxYear,\n      HH: 23,\n      MM: 59,\n      SS: 59\n    };\n    const minValue = {\n      dd: 1,\n      mm: 1,\n      yy: 0,\n      yyyy: minYear,\n      HH: 0,\n      MM: 0,\n      SS: 0\n    };\n    const conformedValueArr = conformedValue.split('');\n\n    // Check first digit\n    dateFormatArray.forEach(format => {\n      const position = dateFormat.indexOf(format);\n      const maxFirstDigit = parseInt(maxValue[format].toString().substr(0, 1), 10);\n      if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {\n        conformedValueArr[position + 1] = conformedValueArr[position];\n        conformedValueArr[position] = 0;\n        indexesOfPipedChars.push(position);\n      }\n    });\n\n    // Check for invalid date\n    let month = 0;\n    const isInvalid = dateFormatArray.some(format => {\n      const position = dateFormat.indexOf(format);\n      const length = format.length;\n      const textValue = conformedValue.substr(position, length).replace(/\\D/g, '');\n      const value = parseInt(textValue, 10);\n      if (format === 'mm') {\n        month = value || 0;\n      }\n      const maxValueForFormat = format === 'dd' ? maxValueMonth[month] : maxValue[format];\n      if (format === 'yyyy' && (minYear !== 1 || maxYear !== 9999)) {\n        const scopedMaxValue = parseInt(maxValue[format].toString().substring(0, textValue.length), 10);\n        const scopedMinValue = parseInt(minValue[format].toString().substring(0, textValue.length), 10);\n        return value < scopedMinValue || value > scopedMaxValue;\n      }\n      return value > maxValueForFormat || textValue.length === length && value < minValue[format];\n    });\n    if (isInvalid) {\n      return false;\n    }\n    return {\n      value: conformedValueArr.join(''),\n      indexesOfPipedChars\n    };\n  };\n}","map":{"version":3,"names":["maxValueMonth","formatOrder","createAutoCorrectedDatePipe","dateFormat","minYear","maxYear","dateFormatArray","split","sort","a","b","indexOf","conformedValue","indexesOfPipedChars","maxValue","dd","mm","yy","yyyy","HH","MM","SS","minValue","conformedValueArr","forEach","format","position","maxFirstDigit","parseInt","toString","substr","push","month","isInvalid","some","length","textValue","replace","value","maxValueForFormat","scopedMaxValue","substring","scopedMinValue","join"],"sources":["/Users/amurepinho/Documents/GitHub/diagnostico/node_modules/@quillforms/blocklib-date-block/build/renderer/@quillforms/blocklib-date-block/src/renderer/create-autocorrected-date-pipe.js"],"sourcesContent":["const maxValueMonth = [ 31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\r\nconst formatOrder = [ 'yyyy', 'yy', 'mm', 'dd', 'HH', 'MM', 'SS' ];\r\nexport default function createAutoCorrectedDatePipe(\r\n\tdateFormat = 'mm dd yyyy',\r\n\t{ minYear = 1, maxYear = 9999 } = {}\r\n) {\r\n\tconst dateFormatArray = dateFormat\r\n\t\t.split( /[^dmyHMS]+/ )\r\n\t\t.sort(\r\n\t\t\t( a, b ) => formatOrder.indexOf( a ) - formatOrder.indexOf( b )\r\n\t\t);\r\n\treturn function ( conformedValue ) {\r\n\t\tconst indexesOfPipedChars = [];\r\n\t\tconst maxValue = {\r\n\t\t\tdd: 31,\r\n\t\t\tmm: 12,\r\n\t\t\tyy: 99,\r\n\t\t\tyyyy: maxYear,\r\n\t\t\tHH: 23,\r\n\t\t\tMM: 59,\r\n\t\t\tSS: 59,\r\n\t\t};\r\n\t\tconst minValue = {\r\n\t\t\tdd: 1,\r\n\t\t\tmm: 1,\r\n\t\t\tyy: 0,\r\n\t\t\tyyyy: minYear,\r\n\t\t\tHH: 0,\r\n\t\t\tMM: 0,\r\n\t\t\tSS: 0,\r\n\t\t};\r\n\t\tconst conformedValueArr = conformedValue.split( '' );\r\n\r\n\t\t// Check first digit\r\n\t\tdateFormatArray.forEach( ( format ) => {\r\n\t\t\tconst position = dateFormat.indexOf( format );\r\n\t\t\tconst maxFirstDigit = parseInt(\r\n\t\t\t\tmaxValue[ format ].toString().substr( 0, 1 ),\r\n\t\t\t\t10\r\n\t\t\t);\r\n\r\n\t\t\tif (\r\n\t\t\t\tparseInt( conformedValueArr[ position ], 10 ) > maxFirstDigit\r\n\t\t\t) {\r\n\t\t\t\tconformedValueArr[ position + 1 ] =\r\n\t\t\t\t\tconformedValueArr[ position ];\r\n\t\t\t\tconformedValueArr[ position ] = 0;\r\n\t\t\t\tindexesOfPipedChars.push( position );\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t\t// Check for invalid date\r\n\t\tlet month = 0;\r\n\t\tconst isInvalid = dateFormatArray.some( ( format ) => {\r\n\t\t\tconst position = dateFormat.indexOf( format );\r\n\t\t\tconst length = format.length;\r\n\t\t\tconst textValue = conformedValue\r\n\t\t\t\t.substr( position, length )\r\n\t\t\t\t.replace( /\\D/g, '' );\r\n\t\t\tconst value = parseInt( textValue, 10 );\r\n\t\t\tif ( format === 'mm' ) {\r\n\t\t\t\tmonth = value || 0;\r\n\t\t\t}\r\n\t\t\tconst maxValueForFormat =\r\n\t\t\t\tformat === 'dd' ? maxValueMonth[ month ] : maxValue[ format ];\r\n\t\t\tif ( format === 'yyyy' && ( minYear !== 1 || maxYear !== 9999 ) ) {\r\n\t\t\t\tconst scopedMaxValue = parseInt(\r\n\t\t\t\t\tmaxValue[ format ]\r\n\t\t\t\t\t\t.toString()\r\n\t\t\t\t\t\t.substring( 0, textValue.length ),\r\n\t\t\t\t\t10\r\n\t\t\t\t);\r\n\t\t\t\tconst scopedMinValue = parseInt(\r\n\t\t\t\t\tminValue[ format ]\r\n\t\t\t\t\t\t.toString()\r\n\t\t\t\t\t\t.substring( 0, textValue.length ),\r\n\t\t\t\t\t10\r\n\t\t\t\t);\r\n\t\t\t\treturn value < scopedMinValue || value > scopedMaxValue;\r\n\t\t\t}\r\n\t\t\treturn (\r\n\t\t\t\tvalue > maxValueForFormat ||\r\n\t\t\t\t( textValue.length === length && value < minValue[ format ] )\r\n\t\t\t);\r\n\t\t} );\r\n\r\n\t\tif ( isInvalid ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tvalue: conformedValueArr.join( '' ),\r\n\t\t\tindexesOfPipedChars,\r\n\t\t};\r\n\t};\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}