{"ast":null,"code":"/**\n * WordPress dependencies\n */\nimport isShallowEqual from '@wordpress/is-shallow-equal';\n\n/** @typedef {import('./types').HistoryRecord}  HistoryRecord */\n/** @typedef {import('./types').HistoryChange}  HistoryChange */\n/** @typedef {import('./types').HistoryChanges} HistoryChanges */\n/** @typedef {import('./types').UndoManager} UndoManager */\n\n/**\n * Merge changes for a single item into a record of changes.\n *\n * @param {Record< string, HistoryChange >} changes1 Previous changes\n * @param {Record< string, HistoryChange >} changes2 NextChanges\n *\n * @return {Record< string, HistoryChange >} Merged changes\n */\nfunction mergeHistoryChanges(changes1, changes2) {\n  /**\n   * @type {Record< string, HistoryChange >}\n   */\n  const newChanges = {\n    ...changes1\n  };\n  Object.entries(changes2).forEach(([key, value]) => {\n    if (newChanges[key]) {\n      newChanges[key] = {\n        ...newChanges[key],\n        to: value.to\n      };\n    } else {\n      newChanges[key] = value;\n    }\n  });\n  return newChanges;\n}\n\n/**\n * Adds history changes for a single item into a record of changes.\n *\n * @param {HistoryRecord}  record  The record to merge into.\n * @param {HistoryChanges} changes The changes to merge.\n */\nconst addHistoryChangesIntoRecord = (record, changes) => {\n  const existingChangesIndex = record?.findIndex(({\n    id: recordIdentifier\n  }) => {\n    return typeof recordIdentifier === 'string' ? recordIdentifier === changes.id : isShallowEqual(recordIdentifier, changes.id);\n  });\n  const nextRecord = [...record];\n  if (existingChangesIndex !== -1) {\n    // If the edit is already in the stack leave the initial \"from\" value.\n    nextRecord[existingChangesIndex] = {\n      id: changes.id,\n      changes: mergeHistoryChanges(nextRecord[existingChangesIndex].changes, changes.changes)\n    };\n  } else {\n    nextRecord.push(changes);\n  }\n  return nextRecord;\n};\n\n/**\n * Creates an undo manager.\n *\n * @return {UndoManager} Undo manager.\n */\nexport function createUndoManager() {\n  /**\n   * @type {HistoryRecord[]}\n   */\n  let history = [];\n  /**\n   * @type {HistoryRecord}\n   */\n  let stagedRecord = [];\n  /**\n   * @type {number}\n   */\n  let offset = 0;\n  const dropPendingRedos = () => {\n    history = history.slice(0, offset || undefined);\n    offset = 0;\n  };\n  const appendStagedRecordToLatestHistoryRecord = () => {\n    var _history$index;\n    const index = history.length === 0 ? 0 : history.length - 1;\n    let latestRecord = (_history$index = history[index]) !== null && _history$index !== void 0 ? _history$index : [];\n    stagedRecord.forEach(changes => {\n      latestRecord = addHistoryChangesIntoRecord(latestRecord, changes);\n    });\n    stagedRecord = [];\n    history[index] = latestRecord;\n  };\n\n  /**\n   * Checks whether a record is empty.\n   * A record is considered empty if it the changes keep the same values.\n   * Also updates to function values are ignored.\n   *\n   * @param {HistoryRecord} record\n   * @return {boolean} Whether the record is empty.\n   */\n  const isRecordEmpty = record => {\n    const filteredRecord = record.filter(({\n      changes\n    }) => {\n      return Object.values(changes).some(({\n        from,\n        to\n      }) => typeof from !== 'function' && typeof to !== 'function' && !isShallowEqual(from, to));\n    });\n    return !filteredRecord.length;\n  };\n  return {\n    /**\n     * Record changes into the history.\n     *\n     * @param {HistoryRecord=} record   A record of changes to record.\n     * @param {boolean}        isStaged Whether to immediately create an undo point or not.\n     */\n    addRecord(record, isStaged = false) {\n      const isEmpty = !record || isRecordEmpty(record);\n      if (isStaged) {\n        if (isEmpty) {\n          return;\n        }\n        record.forEach(changes => {\n          stagedRecord = addHistoryChangesIntoRecord(stagedRecord, changes);\n        });\n      } else {\n        dropPendingRedos();\n        if (stagedRecord.length) {\n          appendStagedRecordToLatestHistoryRecord();\n        }\n        if (isEmpty) {\n          return;\n        }\n        history.push(record);\n      }\n    },\n    undo() {\n      if (stagedRecord.length) {\n        dropPendingRedos();\n        appendStagedRecordToLatestHistoryRecord();\n      }\n      const undoRecord = history[history.length - 1 + offset];\n      if (!undoRecord) {\n        return;\n      }\n      offset -= 1;\n      return undoRecord;\n    },\n    redo() {\n      const redoRecord = history[history.length + offset];\n      if (!redoRecord) {\n        return;\n      }\n      offset += 1;\n      return redoRecord;\n    },\n    hasUndo() {\n      return !!history[history.length - 1 + offset];\n    },\n    hasRedo() {\n      return !!history[history.length + offset];\n    }\n  };\n}","map":{"version":3,"names":["isShallowEqual","mergeHistoryChanges","changes1","changes2","newChanges","Object","entries","forEach","key","value","to","addHistoryChangesIntoRecord","record","changes","existingChangesIndex","findIndex","id","recordIdentifier","nextRecord","push","createUndoManager","history","stagedRecord","offset","dropPendingRedos","slice","undefined","appendStagedRecordToLatestHistoryRecord","_history$index","index","length","latestRecord","isRecordEmpty","filteredRecord","filter","values","some","from","addRecord","isStaged","isEmpty","undo","undoRecord","redo","redoRecord","hasUndo","hasRedo"],"sources":["/Users/amurepinho/Documents/GitHub/diagnostico/node_modules/@wordpress/undo-manager/build-module/@wordpress/undo-manager/src/index.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport isShallowEqual from '@wordpress/is-shallow-equal';\n\n/** @typedef {import('./types').HistoryRecord}  HistoryRecord */\n/** @typedef {import('./types').HistoryChange}  HistoryChange */\n/** @typedef {import('./types').HistoryChanges} HistoryChanges */\n/** @typedef {import('./types').UndoManager} UndoManager */\n\n/**\n * Merge changes for a single item into a record of changes.\n *\n * @param {Record< string, HistoryChange >} changes1 Previous changes\n * @param {Record< string, HistoryChange >} changes2 NextChanges\n *\n * @return {Record< string, HistoryChange >} Merged changes\n */\nfunction mergeHistoryChanges( changes1, changes2 ) {\n\t/**\n\t * @type {Record< string, HistoryChange >}\n\t */\n\tconst newChanges = { ...changes1 };\n\tObject.entries( changes2 ).forEach( ( [ key, value ] ) => {\n\t\tif ( newChanges[ key ] ) {\n\t\t\tnewChanges[ key ] = { ...newChanges[ key ], to: value.to };\n\t\t} else {\n\t\t\tnewChanges[ key ] = value;\n\t\t}\n\t} );\n\n\treturn newChanges;\n}\n\n/**\n * Adds history changes for a single item into a record of changes.\n *\n * @param {HistoryRecord}  record  The record to merge into.\n * @param {HistoryChanges} changes The changes to merge.\n */\nconst addHistoryChangesIntoRecord = ( record, changes ) => {\n\tconst existingChangesIndex = record?.findIndex(\n\t\t( { id: recordIdentifier } ) => {\n\t\t\treturn typeof recordIdentifier === 'string'\n\t\t\t\t? recordIdentifier === changes.id\n\t\t\t\t: isShallowEqual( recordIdentifier, changes.id );\n\t\t}\n\t);\n\tconst nextRecord = [ ...record ];\n\n\tif ( existingChangesIndex !== -1 ) {\n\t\t// If the edit is already in the stack leave the initial \"from\" value.\n\t\tnextRecord[ existingChangesIndex ] = {\n\t\t\tid: changes.id,\n\t\t\tchanges: mergeHistoryChanges(\n\t\t\t\tnextRecord[ existingChangesIndex ].changes,\n\t\t\t\tchanges.changes\n\t\t\t),\n\t\t};\n\t} else {\n\t\tnextRecord.push( changes );\n\t}\n\treturn nextRecord;\n};\n\n/**\n * Creates an undo manager.\n *\n * @return {UndoManager} Undo manager.\n */\nexport function createUndoManager() {\n\t/**\n\t * @type {HistoryRecord[]}\n\t */\n\tlet history = [];\n\t/**\n\t * @type {HistoryRecord}\n\t */\n\tlet stagedRecord = [];\n\t/**\n\t * @type {number}\n\t */\n\tlet offset = 0;\n\n\tconst dropPendingRedos = () => {\n\t\thistory = history.slice( 0, offset || undefined );\n\t\toffset = 0;\n\t};\n\n\tconst appendStagedRecordToLatestHistoryRecord = () => {\n\t\tconst index = history.length === 0 ? 0 : history.length - 1;\n\t\tlet latestRecord = history[ index ] ?? [];\n\t\tstagedRecord.forEach( ( changes ) => {\n\t\t\tlatestRecord = addHistoryChangesIntoRecord( latestRecord, changes );\n\t\t} );\n\t\tstagedRecord = [];\n\t\thistory[ index ] = latestRecord;\n\t};\n\n\t/**\n\t * Checks whether a record is empty.\n\t * A record is considered empty if it the changes keep the same values.\n\t * Also updates to function values are ignored.\n\t *\n\t * @param {HistoryRecord} record\n\t * @return {boolean} Whether the record is empty.\n\t */\n\tconst isRecordEmpty = ( record ) => {\n\t\tconst filteredRecord = record.filter( ( { changes } ) => {\n\t\t\treturn Object.values( changes ).some(\n\t\t\t\t( { from, to } ) =>\n\t\t\t\t\ttypeof from !== 'function' &&\n\t\t\t\t\ttypeof to !== 'function' &&\n\t\t\t\t\t! isShallowEqual( from, to )\n\t\t\t);\n\t\t} );\n\t\treturn ! filteredRecord.length;\n\t};\n\n\treturn {\n\t\t/**\n\t\t * Record changes into the history.\n\t\t *\n\t\t * @param {HistoryRecord=} record   A record of changes to record.\n\t\t * @param {boolean}        isStaged Whether to immediately create an undo point or not.\n\t\t */\n\t\taddRecord( record, isStaged = false ) {\n\t\t\tconst isEmpty = ! record || isRecordEmpty( record );\n\t\t\tif ( isStaged ) {\n\t\t\t\tif ( isEmpty ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\trecord.forEach( ( changes ) => {\n\t\t\t\t\tstagedRecord = addHistoryChangesIntoRecord(\n\t\t\t\t\t\tstagedRecord,\n\t\t\t\t\t\tchanges\n\t\t\t\t\t);\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tdropPendingRedos();\n\t\t\t\tif ( stagedRecord.length ) {\n\t\t\t\t\tappendStagedRecordToLatestHistoryRecord();\n\t\t\t\t}\n\t\t\t\tif ( isEmpty ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thistory.push( record );\n\t\t\t}\n\t\t},\n\n\t\tundo() {\n\t\t\tif ( stagedRecord.length ) {\n\t\t\t\tdropPendingRedos();\n\t\t\t\tappendStagedRecordToLatestHistoryRecord();\n\t\t\t}\n\t\t\tconst undoRecord = history[ history.length - 1 + offset ];\n\t\t\tif ( ! undoRecord ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toffset -= 1;\n\t\t\treturn undoRecord;\n\t\t},\n\n\t\tredo() {\n\t\t\tconst redoRecord = history[ history.length + offset ];\n\t\t\tif ( ! redoRecord ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toffset += 1;\n\t\t\treturn redoRecord;\n\t\t},\n\n\t\thasUndo() {\n\t\t\treturn !! history[ history.length - 1 + offset ];\n\t\t},\n\n\t\thasRedo() {\n\t\t\treturn !! history[ history.length + offset ];\n\t\t},\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}