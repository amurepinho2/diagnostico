{"ast":null,"code":"/**\n * Memize options object.\n *\n * @typedef MemizeOptions\n *\n * @property {number} [maxSize] Maximum size of the cache.\n */\n\n/**\n * Internal cache entry.\n *\n * @typedef MemizeCacheNode\n *\n * @property {?MemizeCacheNode|undefined} [prev] Previous node.\n * @property {?MemizeCacheNode|undefined} [next] Next node.\n * @property {Array<*>}                   args   Function arguments for cache\n *                                               entry.\n * @property {*}                          val    Function result.\n */\n\n/**\n * Properties of the enhanced function for controlling cache.\n *\n * @typedef MemizeMemoizedFunction\n *\n * @property {()=>void} clear Clear the cache.\n */\n\n/**\n * Accepts a function to be memoized, and returns a new memoized function, with\n * optional options.\n *\n * @template {(...args: any[]) => any} F\n *\n * @param {F}             fn        Function to memoize.\n * @param {MemizeOptions} [options] Options object.\n *\n * @return {((...args: Parameters<F>) => ReturnType<F>) & MemizeMemoizedFunction} Memoized function.\n */\nfunction memize(fn, options) {\n  var size = 0;\n\n  /** @type {?MemizeCacheNode|undefined} */\n  var head;\n\n  /** @type {?MemizeCacheNode|undefined} */\n  var tail;\n  options = options || {};\n  function memoized( /* ...args */\n  ) {\n    var node = head,\n      len = arguments.length,\n      args,\n      i;\n    searchCache: while (node) {\n      // Perform a shallow equality test to confirm that whether the node\n      // under test is a candidate for the arguments passed. Two arrays\n      // are shallowly equal if their length matches and each entry is\n      // strictly equal between the two sets. Avoid abstracting to a\n      // function which could incur an arguments leaking deoptimization.\n\n      // Check whether node arguments match arguments length\n      if (node.args.length !== arguments.length) {\n        node = node.next;\n        continue;\n      }\n\n      // Check whether node arguments match arguments values\n      for (i = 0; i < len; i++) {\n        if (node.args[i] !== arguments[i]) {\n          node = node.next;\n          continue searchCache;\n        }\n      }\n\n      // At this point we can assume we've found a match\n\n      // Surface matched node to head if not already\n      if (node !== head) {\n        // As tail, shift to previous. Must only shift if not also\n        // head, since if both head and tail, there is no previous.\n        if (node === tail) {\n          tail = node.prev;\n        }\n\n        // Adjust siblings to point to each other. If node was tail,\n        // this also handles new tail's empty `next` assignment.\n        /** @type {MemizeCacheNode} */\n        node.prev.next = node.next;\n        if (node.next) {\n          node.next.prev = node.prev;\n        }\n        node.next = head;\n        node.prev = null;\n        /** @type {MemizeCacheNode} */\n        head.prev = node;\n        head = node;\n      }\n\n      // Return immediately\n      return node.val;\n    }\n\n    // No cached value found. Continue to insertion phase:\n\n    // Create a copy of arguments (avoid leaking deoptimization)\n    args = new Array(len);\n    for (i = 0; i < len; i++) {\n      args[i] = arguments[i];\n    }\n    node = {\n      args: args,\n      // Generate the result from original function\n      val: fn.apply(null, args)\n    };\n\n    // Don't need to check whether node is already head, since it would\n    // have been returned above already if it was\n\n    // Shift existing head down list\n    if (head) {\n      head.prev = node;\n      node.next = head;\n    } else {\n      // If no head, follows that there's no tail (at initial or reset)\n      tail = node;\n    }\n\n    // Trim tail if we're reached max size and are pending cache insertion\n    if (size === /** @type {MemizeOptions} */options.maxSize) {\n      tail = /** @type {MemizeCacheNode} */tail.prev;\n      /** @type {MemizeCacheNode} */\n      tail.next = null;\n    } else {\n      size++;\n    }\n    head = node;\n    return node.val;\n  }\n  memoized.clear = function () {\n    head = null;\n    tail = null;\n    size = 0;\n  };\n\n  // Ignore reason: There's not a clear solution to create an intersection of\n  // the function with additional properties, where the goal is to retain the\n  // function signature of the incoming argument and add control properties\n  // on the return value.\n\n  // @ts-ignore\n  return memoized;\n}\nexport { memize as default };","map":{"version":3,"names":["memize","fn","options","size","head","tail","memoized","node","len","arguments","length","args","i","searchCache","next","prev","val","Array","apply","maxSize","clear","default"],"sources":["/Users/amurepinho/Documents/GitHub/diagnostico/node_modules/memize/dist/index.js"],"sourcesContent":["/**\n * Memize options object.\n *\n * @typedef MemizeOptions\n *\n * @property {number} [maxSize] Maximum size of the cache.\n */\n\n/**\n * Internal cache entry.\n *\n * @typedef MemizeCacheNode\n *\n * @property {?MemizeCacheNode|undefined} [prev] Previous node.\n * @property {?MemizeCacheNode|undefined} [next] Next node.\n * @property {Array<*>}                   args   Function arguments for cache\n *                                               entry.\n * @property {*}                          val    Function result.\n */\n\n/**\n * Properties of the enhanced function for controlling cache.\n *\n * @typedef MemizeMemoizedFunction\n *\n * @property {()=>void} clear Clear the cache.\n */\n\n/**\n * Accepts a function to be memoized, and returns a new memoized function, with\n * optional options.\n *\n * @template {(...args: any[]) => any} F\n *\n * @param {F}             fn        Function to memoize.\n * @param {MemizeOptions} [options] Options object.\n *\n * @return {((...args: Parameters<F>) => ReturnType<F>) & MemizeMemoizedFunction} Memoized function.\n */\nfunction memize(fn, options) {\n\tvar size = 0;\n\n\t/** @type {?MemizeCacheNode|undefined} */\n\tvar head;\n\n\t/** @type {?MemizeCacheNode|undefined} */\n\tvar tail;\n\n\toptions = options || {};\n\n\tfunction memoized(/* ...args */) {\n\t\tvar node = head,\n\t\t\tlen = arguments.length,\n\t\t\targs,\n\t\t\ti;\n\n\t\tsearchCache: while (node) {\n\t\t\t// Perform a shallow equality test to confirm that whether the node\n\t\t\t// under test is a candidate for the arguments passed. Two arrays\n\t\t\t// are shallowly equal if their length matches and each entry is\n\t\t\t// strictly equal between the two sets. Avoid abstracting to a\n\t\t\t// function which could incur an arguments leaking deoptimization.\n\n\t\t\t// Check whether node arguments match arguments length\n\t\t\tif (node.args.length !== arguments.length) {\n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check whether node arguments match arguments values\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif (node.args[i] !== arguments[i]) {\n\t\t\t\t\tnode = node.next;\n\t\t\t\t\tcontinue searchCache;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// At this point we can assume we've found a match\n\n\t\t\t// Surface matched node to head if not already\n\t\t\tif (node !== head) {\n\t\t\t\t// As tail, shift to previous. Must only shift if not also\n\t\t\t\t// head, since if both head and tail, there is no previous.\n\t\t\t\tif (node === tail) {\n\t\t\t\t\ttail = node.prev;\n\t\t\t\t}\n\n\t\t\t\t// Adjust siblings to point to each other. If node was tail,\n\t\t\t\t// this also handles new tail's empty `next` assignment.\n\t\t\t\t/** @type {MemizeCacheNode} */ (node.prev).next = node.next;\n\t\t\t\tif (node.next) {\n\t\t\t\t\tnode.next.prev = node.prev;\n\t\t\t\t}\n\n\t\t\t\tnode.next = head;\n\t\t\t\tnode.prev = null;\n\t\t\t\t/** @type {MemizeCacheNode} */ (head).prev = node;\n\t\t\t\thead = node;\n\t\t\t}\n\n\t\t\t// Return immediately\n\t\t\treturn node.val;\n\t\t}\n\n\t\t// No cached value found. Continue to insertion phase:\n\n\t\t// Create a copy of arguments (avoid leaking deoptimization)\n\t\targs = new Array(len);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\tnode = {\n\t\t\targs: args,\n\n\t\t\t// Generate the result from original function\n\t\t\tval: fn.apply(null, args),\n\t\t};\n\n\t\t// Don't need to check whether node is already head, since it would\n\t\t// have been returned above already if it was\n\n\t\t// Shift existing head down list\n\t\tif (head) {\n\t\t\thead.prev = node;\n\t\t\tnode.next = head;\n\t\t} else {\n\t\t\t// If no head, follows that there's no tail (at initial or reset)\n\t\t\ttail = node;\n\t\t}\n\n\t\t// Trim tail if we're reached max size and are pending cache insertion\n\t\tif (size === /** @type {MemizeOptions} */ (options).maxSize) {\n\t\t\ttail = /** @type {MemizeCacheNode} */ (tail).prev;\n\t\t\t/** @type {MemizeCacheNode} */ (tail).next = null;\n\t\t} else {\n\t\t\tsize++;\n\t\t}\n\n\t\thead = node;\n\n\t\treturn node.val;\n\t}\n\n\tmemoized.clear = function () {\n\t\thead = null;\n\t\ttail = null;\n\t\tsize = 0;\n\t};\n\n\t// Ignore reason: There's not a clear solution to create an intersection of\n\t// the function with additional properties, where the goal is to retain the\n\t// function signature of the incoming argument and add control properties\n\t// on the return value.\n\n\t// @ts-ignore\n\treturn memoized;\n}\n\nexport { memize as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}