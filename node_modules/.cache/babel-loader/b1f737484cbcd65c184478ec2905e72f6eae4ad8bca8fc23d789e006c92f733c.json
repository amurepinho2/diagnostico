{"ast":null,"code":"/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Get the rectangle of a given Range. Returns `null` if no suitable rectangle\n * can be found.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect?} The rectangle.\n */\nexport default function getRectangleFromRange(range) {\n  // For uncollapsed ranges, get the rectangle that bounds the contents of the\n  // range; this a rectangle enclosing the union of the bounding rectangles\n  // for all the elements in the range.\n  if (!range.collapsed) {\n    const rects = Array.from(range.getClientRects());\n\n    // If there's just a single rect, return it.\n    if (rects.length === 1) {\n      return rects[0];\n    }\n\n    // Ignore tiny selection at the edge of a range.\n    const filteredRects = rects.filter(({\n      width\n    }) => width > 1);\n\n    // If it's full of tiny selections, return browser default.\n    if (filteredRects.length === 0) {\n      return range.getBoundingClientRect();\n    }\n    if (filteredRects.length === 1) {\n      return filteredRects[0];\n    }\n    let {\n      top: furthestTop,\n      bottom: furthestBottom,\n      left: furthestLeft,\n      right: furthestRight\n    } = filteredRects[0];\n    for (const {\n      top,\n      bottom,\n      left,\n      right\n    } of filteredRects) {\n      if (top < furthestTop) {\n        furthestTop = top;\n      }\n      if (bottom > furthestBottom) {\n        furthestBottom = bottom;\n      }\n      if (left < furthestLeft) {\n        furthestLeft = left;\n      }\n      if (right > furthestRight) {\n        furthestRight = right;\n      }\n    }\n    return new window.DOMRect(furthestLeft, furthestTop, furthestRight - furthestLeft, furthestBottom - furthestTop);\n  }\n  const {\n    startContainer\n  } = range;\n  const {\n    ownerDocument\n  } = startContainer;\n\n  // Correct invalid \"BR\" ranges. The cannot contain any children.\n  if (startContainer.nodeName === 'BR') {\n    const {\n      parentNode\n    } = startContainer;\n    assertIsDefined(parentNode, 'parentNode');\n    const index = /** @type {Node[]} */Array.from(parentNode.childNodes).indexOf(startContainer);\n    assertIsDefined(ownerDocument, 'ownerDocument');\n    range = ownerDocument.createRange();\n    range.setStart(parentNode, index);\n    range.setEnd(parentNode, index);\n  }\n  const rects = range.getClientRects();\n\n  // If we have multiple rectangles for a collapsed range, there's no way to\n  // know which it is, so don't return anything.\n  if (rects.length > 1) {\n    return null;\n  }\n  let rect = rects[0];\n\n  // If the collapsed range starts (and therefore ends) at an element node,\n  // `getClientRects` can be empty in some browsers. This can be resolved\n  // by adding a temporary text node with zero-width space to the range.\n  //\n  // See: https://stackoverflow.com/a/6847328/995445\n  if (!rect || rect.height === 0) {\n    assertIsDefined(ownerDocument, 'ownerDocument');\n    const padNode = ownerDocument.createTextNode('\\u200b');\n    // Do not modify the live range.\n    range = range.cloneRange();\n    range.insertNode(padNode);\n    rect = range.getClientRects()[0];\n    assertIsDefined(padNode.parentNode, 'padNode.parentNode');\n    padNode.parentNode.removeChild(padNode);\n  }\n  return rect;\n}","map":{"version":3,"names":["assertIsDefined","getRectangleFromRange","range","collapsed","rects","Array","from","getClientRects","length","filteredRects","filter","width","getBoundingClientRect","top","furthestTop","bottom","furthestBottom","left","furthestLeft","right","furthestRight","window","DOMRect","startContainer","ownerDocument","nodeName","parentNode","index","childNodes","indexOf","createRange","setStart","setEnd","rect","height","padNode","createTextNode","cloneRange","insertNode","removeChild"],"sources":["/Users/amurepinho/Documents/GitHub/diagnostico/node_modules/@wordpress/dom/build-module/dom/@wordpress/dom/src/dom/get-rectangle-from-range.js"],"sourcesContent":["/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Get the rectangle of a given Range. Returns `null` if no suitable rectangle\n * can be found.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect?} The rectangle.\n */\nexport default function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\tconst rects = Array.from( range.getClientRects() );\n\n\t\t// If there's just a single rect, return it.\n\t\tif ( rects.length === 1 ) {\n\t\t\treturn rects[ 0 ];\n\t\t}\n\n\t\t// Ignore tiny selection at the edge of a range.\n\t\tconst filteredRects = rects.filter( ( { width } ) => width > 1 );\n\n\t\t// If it's full of tiny selections, return browser default.\n\t\tif ( filteredRects.length === 0 ) {\n\t\t\treturn range.getBoundingClientRect();\n\t\t}\n\n\t\tif ( filteredRects.length === 1 ) {\n\t\t\treturn filteredRects[ 0 ];\n\t\t}\n\n\t\tlet {\n\t\t\ttop: furthestTop,\n\t\t\tbottom: furthestBottom,\n\t\t\tleft: furthestLeft,\n\t\t\tright: furthestRight,\n\t\t} = filteredRects[ 0 ];\n\n\t\tfor ( const { top, bottom, left, right } of filteredRects ) {\n\t\t\tif ( top < furthestTop ) {\n\t\t\t\tfurthestTop = top;\n\t\t\t}\n\t\t\tif ( bottom > furthestBottom ) {\n\t\t\t\tfurthestBottom = bottom;\n\t\t\t}\n\t\t\tif ( left < furthestLeft ) {\n\t\t\t\tfurthestLeft = left;\n\t\t\t}\n\t\t\tif ( right > furthestRight ) {\n\t\t\t\tfurthestRight = right;\n\t\t\t}\n\t\t}\n\n\t\treturn new window.DOMRect(\n\t\t\tfurthestLeft,\n\t\t\tfurthestTop,\n\t\t\tfurthestRight - furthestLeft,\n\t\t\tfurthestBottom - furthestTop\n\t\t);\n\t}\n\n\tconst { startContainer } = range;\n\tconst { ownerDocument } = startContainer;\n\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\n\tif ( startContainer.nodeName === 'BR' ) {\n\t\tconst { parentNode } = startContainer;\n\t\tassertIsDefined( parentNode, 'parentNode' );\n\t\tconst index = /** @type {Node[]} */ (\n\t\t\tArray.from( parentNode.childNodes )\n\t\t).indexOf( startContainer );\n\n\t\tassertIsDefined( ownerDocument, 'ownerDocument' );\n\t\trange = ownerDocument.createRange();\n\t\trange.setStart( parentNode, index );\n\t\trange.setEnd( parentNode, index );\n\t}\n\n\tconst rects = range.getClientRects();\n\n\t// If we have multiple rectangles for a collapsed range, there's no way to\n\t// know which it is, so don't return anything.\n\tif ( rects.length > 1 ) {\n\t\treturn null;\n\t}\n\n\tlet rect = rects[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect || rect.height === 0 ) {\n\t\tassertIsDefined( ownerDocument, 'ownerDocument' );\n\t\tconst padNode = ownerDocument.createTextNode( '\\u200b' );\n\t\t// Do not modify the live range.\n\t\trange = range.cloneRange();\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tassertIsDefined( padNode.parentNode, 'padNode.parentNode' );\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}