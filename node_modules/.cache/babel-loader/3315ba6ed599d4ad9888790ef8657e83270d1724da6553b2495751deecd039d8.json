{"ast":null,"code":"/**\n * Operator callback functions.\n *\n * @type {Object}\n */\nvar OPERATORS = {\n  '!': function (a) {\n    return !a;\n  },\n  '*': function (a, b) {\n    return a * b;\n  },\n  '/': function (a, b) {\n    return a / b;\n  },\n  '%': function (a, b) {\n    return a % b;\n  },\n  '+': function (a, b) {\n    return a + b;\n  },\n  '-': function (a, b) {\n    return a - b;\n  },\n  '<': function (a, b) {\n    return a < b;\n  },\n  '<=': function (a, b) {\n    return a <= b;\n  },\n  '>': function (a, b) {\n    return a > b;\n  },\n  '>=': function (a, b) {\n    return a >= b;\n  },\n  '==': function (a, b) {\n    return a === b;\n  },\n  '!=': function (a, b) {\n    return a !== b;\n  },\n  '&&': function (a, b) {\n    return a && b;\n  },\n  '||': function (a, b) {\n    return a || b;\n  },\n  '?:': function (a, b, c) {\n    if (a) {\n      throw b;\n    }\n    return c;\n  }\n};\n\n/**\n * Given an array of postfix terms and operand variables, returns the result of\n * the postfix evaluation.\n *\n * @example\n *\n * ```js\n * import evaluate from '@tannin/evaluate';\n *\n * // 3 + 4 * 5 / 6 ⇒ '3 4 5 * 6 / +'\n * const terms = [ '3', '4', '5', '*', '6', '/', '+' ];\n *\n * evaluate( terms, {} );\n * // ⇒ 6.333333333333334\n * ```\n *\n * @param {string[]} postfix   Postfix terms.\n * @param {Object}   variables Operand variables.\n *\n * @return {*} Result of evaluation.\n */\nexport default function evaluate(postfix, variables) {\n  var stack = [],\n    i,\n    j,\n    args,\n    getOperatorResult,\n    term,\n    value;\n  for (i = 0; i < postfix.length; i++) {\n    term = postfix[i];\n    getOperatorResult = OPERATORS[term];\n    if (getOperatorResult) {\n      // Pop from stack by number of function arguments.\n      j = getOperatorResult.length;\n      args = Array(j);\n      while (j--) {\n        args[j] = stack.pop();\n      }\n      try {\n        value = getOperatorResult.apply(null, args);\n      } catch (earlyReturn) {\n        return earlyReturn;\n      }\n    } else if (variables.hasOwnProperty(term)) {\n      value = variables[term];\n    } else {\n      value = +term;\n    }\n    stack.push(value);\n  }\n  return stack[0];\n}","map":{"version":3,"names":["OPERATORS","!","a","*","b","/","%","+","-","<","<=",">",">=","==","!=","&&","||","?:","c","evaluate","postfix","variables","stack","i","j","args","getOperatorResult","term","value","length","Array","pop","apply","earlyReturn","hasOwnProperty","push"],"sources":["/Users/amurepinho/Documents/GitHub/diagnostico/node_modules/@tannin/evaluate/index.js"],"sourcesContent":["/**\n * Operator callback functions.\n *\n * @type {Object}\n */\nvar OPERATORS = {\n\t'!': function( a ) {\n\t\treturn ! a;\n\t},\n\t'*': function( a, b ) {\n\t\treturn a * b;\n\t},\n\t'/': function( a, b ) {\n\t\treturn a / b;\n\t},\n\t'%': function( a, b ) {\n\t\treturn a % b;\n\t},\n\t'+': function( a, b ) {\n\t\treturn a + b;\n\t},\n\t'-': function( a, b ) {\n\t\treturn a - b;\n\t},\n\t'<': function( a, b ) {\n\t\treturn a < b;\n\t},\n\t'<=': function( a, b ) {\n\t\treturn a <= b;\n\t},\n\t'>': function( a, b ) {\n\t\treturn a > b;\n\t},\n\t'>=': function( a, b ) {\n\t\treturn a >= b;\n\t},\n\t'==': function( a, b ) {\n\t\treturn a === b;\n\t},\n\t'!=': function( a, b ) {\n\t\treturn a !== b;\n\t},\n\t'&&': function( a, b ) {\n\t\treturn a && b;\n\t},\n\t'||': function( a, b ) {\n\t\treturn a || b;\n\t},\n\t'?:': function( a, b, c ) {\n\t\tif ( a ) {\n\t\t\tthrow b;\n\t\t}\n\n\t\treturn c;\n\t},\n};\n\n/**\n * Given an array of postfix terms and operand variables, returns the result of\n * the postfix evaluation.\n *\n * @example\n *\n * ```js\n * import evaluate from '@tannin/evaluate';\n *\n * // 3 + 4 * 5 / 6 ⇒ '3 4 5 * 6 / +'\n * const terms = [ '3', '4', '5', '*', '6', '/', '+' ];\n *\n * evaluate( terms, {} );\n * // ⇒ 6.333333333333334\n * ```\n *\n * @param {string[]} postfix   Postfix terms.\n * @param {Object}   variables Operand variables.\n *\n * @return {*} Result of evaluation.\n */\nexport default function evaluate( postfix, variables ) {\n\tvar stack = [],\n\t\ti, j, args, getOperatorResult, term, value;\n\n\tfor ( i = 0; i < postfix.length; i++ ) {\n\t\tterm = postfix[ i ];\n\n\t\tgetOperatorResult = OPERATORS[ term ];\n\t\tif ( getOperatorResult ) {\n\t\t\t// Pop from stack by number of function arguments.\n\t\t\tj = getOperatorResult.length;\n\t\t\targs = Array( j );\n\t\t\twhile ( j-- ) {\n\t\t\t\targs[ j ] = stack.pop();\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tvalue = getOperatorResult.apply( null, args );\n\t\t\t} catch ( earlyReturn ) {\n\t\t\t\treturn earlyReturn;\n\t\t\t}\n\t\t} else if ( variables.hasOwnProperty( term ) ) {\n\t\t\tvalue = variables[ term ];\n\t\t} else {\n\t\t\tvalue = +term;\n\t\t}\n\n\t\tstack.push( value );\n\t}\n\n\treturn stack[ 0 ];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}