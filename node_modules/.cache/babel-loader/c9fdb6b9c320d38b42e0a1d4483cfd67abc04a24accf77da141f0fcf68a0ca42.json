{"ast":null,"code":"var PRECEDENCE, OPENERS, TERMINATORS, PATTERN;\n\n/**\n * Operator precedence mapping.\n *\n * @type {Object}\n */\nPRECEDENCE = {\n  '(': 9,\n  '!': 8,\n  '*': 7,\n  '/': 7,\n  '%': 7,\n  '+': 6,\n  '-': 6,\n  '<': 5,\n  '<=': 5,\n  '>': 5,\n  '>=': 5,\n  '==': 4,\n  '!=': 4,\n  '&&': 3,\n  '||': 2,\n  '?': 1,\n  '?:': 1\n};\n\n/**\n * Characters which signal pair opening, to be terminated by terminators.\n *\n * @type {string[]}\n */\nOPENERS = ['(', '?'];\n\n/**\n * Characters which signal pair termination, the value an array with the\n * opener as its first member. The second member is an optional operator\n * replacement to push to the stack.\n *\n * @type {string[]}\n */\nTERMINATORS = {\n  ')': ['('],\n  ':': ['?', '?:']\n};\n\n/**\n * Pattern matching operators and openers.\n *\n * @type {RegExp}\n */\nPATTERN = /<=|>=|==|!=|&&|\\|\\||\\?:|\\(|!|\\*|\\/|%|\\+|-|<|>|\\?|\\)|:/;\n\n/**\n * Given a C expression, returns the equivalent postfix (Reverse Polish)\n * notation terms as an array.\n *\n * If a postfix string is desired, simply `.join( ' ' )` the result.\n *\n * @example\n *\n * ```js\n * import postfix from '@tannin/postfix';\n *\n * postfix( 'n > 1' );\n * // ⇒ [ 'n', '1', '>' ]\n * ```\n *\n * @param {string} expression C expression.\n *\n * @return {string[]} Postfix terms.\n */\nexport default function postfix(expression) {\n  var terms = [],\n    stack = [],\n    match,\n    operator,\n    term,\n    element;\n  while (match = expression.match(PATTERN)) {\n    operator = match[0];\n\n    // Term is the string preceding the operator match. It may contain\n    // whitespace, and may be empty (if operator is at beginning).\n    term = expression.substr(0, match.index).trim();\n    if (term) {\n      terms.push(term);\n    }\n    while (element = stack.pop()) {\n      if (TERMINATORS[operator]) {\n        if (TERMINATORS[operator][0] === element) {\n          // Substitution works here under assumption that because\n          // the assigned operator will no longer be a terminator, it\n          // will be pushed to the stack during the condition below.\n          operator = TERMINATORS[operator][1] || operator;\n          break;\n        }\n      } else if (OPENERS.indexOf(element) >= 0 || PRECEDENCE[element] < PRECEDENCE[operator]) {\n        // Push to stack if either an opener or when pop reveals an\n        // element of lower precedence.\n        stack.push(element);\n        break;\n      }\n\n      // For each popped from stack, push to terms.\n      terms.push(element);\n    }\n    if (!TERMINATORS[operator]) {\n      stack.push(operator);\n    }\n\n    // Slice matched fragment from expression to continue match.\n    expression = expression.substr(match.index + operator.length);\n  }\n\n  // Push remainder of operand, if exists, to terms.\n  expression = expression.trim();\n  if (expression) {\n    terms.push(expression);\n  }\n\n  // Pop remaining items from stack into terms.\n  return terms.concat(stack.reverse());\n}","map":{"version":3,"names":["PRECEDENCE","OPENERS","TERMINATORS","PATTERN","postfix","expression","terms","stack","match","operator","term","element","substr","index","trim","push","pop","indexOf","length","concat","reverse"],"sources":["/Users/amurepinho/Documents/GitHub/diagnostico/node_modules/@tannin/postfix/index.js"],"sourcesContent":["var PRECEDENCE, OPENERS, TERMINATORS, PATTERN;\n\n/**\n * Operator precedence mapping.\n *\n * @type {Object}\n */\nPRECEDENCE = {\n\t'(': 9,\n\t'!': 8,\n\t'*': 7,\n\t'/': 7,\n\t'%': 7,\n\t'+': 6,\n\t'-': 6,\n\t'<': 5,\n\t'<=': 5,\n\t'>': 5,\n\t'>=': 5,\n\t'==': 4,\n\t'!=': 4,\n\t'&&': 3,\n\t'||': 2,\n\t'?': 1,\n\t'?:': 1,\n};\n\n/**\n * Characters which signal pair opening, to be terminated by terminators.\n *\n * @type {string[]}\n */\nOPENERS = [ '(', '?' ];\n\n/**\n * Characters which signal pair termination, the value an array with the\n * opener as its first member. The second member is an optional operator\n * replacement to push to the stack.\n *\n * @type {string[]}\n */\nTERMINATORS = {\n\t')': [ '(' ],\n\t':': [ '?', '?:' ],\n};\n\n/**\n * Pattern matching operators and openers.\n *\n * @type {RegExp}\n */\nPATTERN = /<=|>=|==|!=|&&|\\|\\||\\?:|\\(|!|\\*|\\/|%|\\+|-|<|>|\\?|\\)|:/;\n\n/**\n * Given a C expression, returns the equivalent postfix (Reverse Polish)\n * notation terms as an array.\n *\n * If a postfix string is desired, simply `.join( ' ' )` the result.\n *\n * @example\n *\n * ```js\n * import postfix from '@tannin/postfix';\n *\n * postfix( 'n > 1' );\n * // ⇒ [ 'n', '1', '>' ]\n * ```\n *\n * @param {string} expression C expression.\n *\n * @return {string[]} Postfix terms.\n */\nexport default function postfix( expression ) {\n\tvar terms = [],\n\t\tstack = [],\n\t\tmatch, operator, term, element;\n\n\twhile ( ( match = expression.match( PATTERN ) ) ) {\n\t\toperator = match[ 0 ];\n\n\t\t// Term is the string preceding the operator match. It may contain\n\t\t// whitespace, and may be empty (if operator is at beginning).\n\t\tterm = expression.substr( 0, match.index ).trim();\n\t\tif ( term ) {\n\t\t\tterms.push( term );\n\t\t}\n\n\t\twhile ( ( element = stack.pop() ) ) {\n\t\t\tif ( TERMINATORS[ operator ] ) {\n\t\t\t\tif ( TERMINATORS[ operator ][ 0 ] === element ) {\n\t\t\t\t\t// Substitution works here under assumption that because\n\t\t\t\t\t// the assigned operator will no longer be a terminator, it\n\t\t\t\t\t// will be pushed to the stack during the condition below.\n\t\t\t\t\toperator = TERMINATORS[ operator ][ 1 ] || operator;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if ( OPENERS.indexOf( element ) >= 0 || PRECEDENCE[ element ] < PRECEDENCE[ operator ] ) {\n\t\t\t\t// Push to stack if either an opener or when pop reveals an\n\t\t\t\t// element of lower precedence.\n\t\t\t\tstack.push( element );\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// For each popped from stack, push to terms.\n\t\t\tterms.push( element );\n\t\t}\n\n\t\tif ( ! TERMINATORS[ operator ] ) {\n\t\t\tstack.push( operator );\n\t\t}\n\n\t\t// Slice matched fragment from expression to continue match.\n\t\texpression = expression.substr( match.index + operator.length );\n\t}\n\n\t// Push remainder of operand, if exists, to terms.\n\texpression = expression.trim();\n\tif ( expression ) {\n\t\tterms.push( expression );\n\t}\n\n\t// Pop remaining items from stack into terms.\n\treturn terms.concat( stack.reverse() );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}