"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _rendererCore = require("@quillforms/renderer-core");
var _data = require("@wordpress/data");
var _lodash = require("lodash");
var _emotion = require("emotion");
var _classnames = _interopRequireDefault(require("classnames"));
var _zenScroll = _interopRequireDefault(require("./zen-scroll"));
/**
 * QuillForms Dependencies
 */

/**
 * WordPress Dependencies
 */

/**
 * External Dependencies
 */

/**
 * Internal Dependencies
 */

const GroupDisplay = ({
  id,
  innerBlocks,
  isTouchScreen,
  ...props
}) => {
  const {
    isErrMsgVisible,
    isActive
  } = (0, _rendererCore.__experimentalUseFieldRenderContext)();
  // By Default, the focus will be on the first item on the group.
  const [refIndex, setRefIndex] = (0, _react.useState)(0);
  const {
    blockTypes,
    answers,
    isAnimating
  } = (0, _data.useSelect)(select => {
    return {
      isAnimating: select('quillForms/renderer-core').isAnimating(),
      blockTypes: select('quillForms/blocks').getBlockTypes(),
      answers: select('quillForms/renderer-core').getAnswers()
    };
  });
  let refAssigned = false;
  const theme = (0, _rendererCore.useBlockTheme)(props.attributes.themeId);
  const {
    setIsFieldValid,
    setFieldValidationErr,
    setIsFieldAnswered,
    setIsFieldPending,
    setFieldPendingMsg,
    setFieldAnswer
  } = (0, _data.useDispatch)('quillForms/renderer-core');
  (0, _react.useEffect)(() => {
    if (isErrMsgVisible) {
      let firstInvalidBlock = null;
      if ((0, _lodash.size)(innerBlocks) > 0) {
        innerBlocks.forEach((block, index) => {
          if (!answers[block.id]?.isValid) {
            if (!firstInvalidBlock) {
              setRefIndex(index);
              firstInvalidBlock = block;
              return false;
            }
          }
        });
      }
      if (firstInvalidBlock && isActive) {
        const defaultDuration = 500;
        const edgeOffset = 30;
        const myDiv = document.querySelector(`#block-${id} .renderer-core-block-scroller`);
        const myScroller = _zenScroll.default.createScroller(myDiv, defaultDuration, edgeOffset);
        const target = document.getElementById(`renderer-components-child-block-${firstInvalidBlock.id}`);
        myScroller.center(target);
        if (['short-text', 'long-text', 'email', 'phone', 'dropdown', 'number', 'date', 'website'].includes(firstInvalidBlock.name) && !isAnimating && !isTouchScreen) {
          setTimeout(() => {
            props?.inputRef?.current?.focus();
          }, 0);
        }
      }
    }
  }, [isErrMsgVisible, isActive, isAnimating]);
  return (0, _react.createElement)(_react.Fragment, null, (0, _lodash.size)(innerBlocks) > 0 && innerBlocks.map((block, index) => {
    var _block$attributes$lab;
    const blockType = blockTypes[block.name];
    let blockLabel = (_block$attributes$lab = block?.attributes?.label) !== null && _block$attributes$lab !== void 0 ? _block$attributes$lab : '';
    if (block?.attributes?.required) blockLabel = blockLabel + ' *';
    const blockProps = {
      ...props,
      isTouchScreen,
      inputRef: refAssigned && refIndex !== index ? null : props.inputRef,
      id: block.id,
      next: _lodash.noop,
      attributes: block.attributes,
      innerBlocks,
      val: answers?.[block.id]?.value,
      setIsValid: val => setIsFieldValid(block.id, val),
      setIsAnswered: val => setIsFieldAnswered(block.id, val),
      setIsPending: val => setIsFieldPending(block.id, val),
      setPendingMsg: val => setFieldPendingMsg(block.id, val),
      setValidationErr: val => setFieldValidationErr(block.id, val),
      setVal: val => setFieldAnswer(block.id, val),
      showNextBtn: _lodash.noop,
      showErrMsg: _lodash.noop
    };
    const context = {
      id,
      blockName: block.name,
      attributes: block.attributes
    };
    refAssigned = true;
    return (0, _react.createElement)(_rendererCore.FieldRenderContextProvider, {
      key: block.id,
      value: context
    }, (0, _react.createElement)("div", {
      className: (0, _emotion.css)`
									margin-bottom: 48px;
									&:last-child {
										margin-bottom: 0;
									}
								`,
      id: `renderer-components-child-block-${block?.id}`
    }, (0, _react.createElement)("div", {
      className: (0, _classnames.default)('renderer-components-child-block-label', (0, _emotion.css)`
											color: ${theme.questionsColor} !important;
											font-family: ${theme.questionsLabelFont} !important;
											@media ( min-width: 768px ) {
												font-size: ${theme.fontSize.lg} !important;
												line-height: ${theme.fontLineHeight.lg} !important;
											}
											@media ( max-width: 767px ) {
												font-size: ${theme.fontSize.sm} !important;
												line-height: ${theme.fontLineHeight.sm} !important;
											}

											margin-bottom: 12px !important;
										`)
    }, (0, _react.createElement)(_rendererCore.HTMLParser, {
      value: blockLabel
    })), (0, _react.createElement)(_react.Fragment, null, blockType?.display && /* @ts-expect-error */
    (0, _react.createElement)(blockType.display, {
      ...blockProps
    })), isErrMsgVisible && answers?.[block?.id]?.validationErr && (0, _react.createElement)("div", {
      className: (0, _emotion.css)`
												margin-top: 20px;
											`
    }, (0, _react.createElement)(_rendererCore.ErrMsg, {
      message: answers[block.id].validationErr
    }))));
  }));
};
var _default = exports.default = GroupDisplay;
//# sourceMappingURL=display.js.map