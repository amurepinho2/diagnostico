import { createElement } from "react";
/* eslint-disable no-nested-ternary */
/**
 * Wordpress Dependencies
 */
import { useSelect, useDispatch } from '@wordpress/data';
import { useEffect, useRef } from '@wordpress/element';
import { doAction } from '@wordpress/hooks';

/**
 * External Dependencies
 */
import classNames from 'classnames';
import { useSwipeable } from 'react-swipeable';
import { Lethargy } from 'lethargy';
import Cookies from 'js-cookie';

/**
 * Internal Dependencies
 */
import FieldRender from '../field-render';
import { useBlocks, useBlockTypes, useFormSettings, useLogic, useHiddenFields, useFormContext, useEditableFields } from '../../hooks';
import useCorrectIncorrectQuiz from '../../hooks/use-correct-incorrect-quiz';
let lastScrollDate = 0;
const lethargy = new Lethargy();
const FieldsWrapper = ({
  applyLogic,
  isActive
}) => {
  const {
    beforeGoingNext,
    isPreview,
    formId
  } = useFormContext();
  const blocks = useBlocks();
  const blockTypes = useBlockTypes();
  const logic = useLogic();
  const hiddenFields = useHiddenFields();
  const correctIncorrectQuiz = useCorrectIncorrectQuiz();
  const settings = useFormSettings();
  const {
    formObj
  } = useFormContext();
  // @ts-ignore saveandcontinue is a property of formObj.
  const {
    saveandcontinue = {}
  } = formObj;
  // @ts-ignore saved_data is a property of formObj.
  const {
    saved_data = {}
  } = formObj;
  const editableFields = useEditableFields(true);
  const ref = useRef(null);
  const {
    swiper
  } = useSelect(select => {
    return {
      swiper: select('quillForms/renderer-core').getSwiperState()
    };
  });
  const {
    walkPath,
    currentBlockId,
    nextBlockId,
    prevBlockId,
    lastActiveBlockId,
    canSwipeNext,
    canSwipePrev,
    isAnimating,
    isCurrentBlockSafeToSwipe
  } = swiper;
  const {
    answers
  } = useSelect(select => {
    return {
      answers: select('quillForms/renderer-core').getAnswers()
    };
  });
  const currentBlockIndex = walkPath.findIndex(block => block.id === currentBlockId);
  const {
    nextBlock
  } = useSelect(select => {
    return {
      nextBlock: nextBlockId ? select('quillForms/renderer-core').getBlockById(nextBlockId) : undefined
    };
  });
  const currentBlockName = walkPath[currentBlockIndex]?.name;
  const currentBlockType = blockTypes?.[currentBlockName];
  const lastActiveBlockIndex = walkPath.findIndex(block => block.id === lastActiveBlockId);
  const {
    setSwiper,
    goNext,
    goPrev,
    goToBlock,
    setIsCurrentBlockSafeToSwipe,
    setIsFieldValid,
    setIsFieldPending,
    setFieldValidationErr,
    setFieldAnswer,
    setCorrectIncorrectDisplay,
    setIsFieldCorrectIncorrectScreenDisplayed
  } = useDispatch('quillForms/renderer-core');
  useEffect(() => {
    if (saveandcontinue?.enable && saved_data?.snapshot) {
      const fields = saved_data?.fields || {};
      Object.keys(fields).forEach(fieldId => {
        setFieldAnswer(fieldId, fields[fieldId].value);
      });
      return;
    }
    if (settings?.saveAnswersInBrowser && !isPreview) {
      // replace localstorage with cookies.
      const answers = Cookies.get(`quillforms-answers-${formId}`) ? JSON.parse(Cookies.get(`quillforms-answers-${formId}`)) : {};
      editableFields.forEach(field => {
        if (answers[field.id]) {
          setFieldAnswer(field.id, answers[field.id].value);
        }
      });
    }
  }, []);
  useEffect(() => {
    if (!isPreview && settings?.saveAnswersInBrowser) {
      // replace localstorage with cookies which will expire in 30 days.
      Cookies.set(`quillforms-answers-${formId}`, JSON.stringify(answers), {
        expires: 30
      }, {
        path: '/'
      });
      Cookies.set(`quillforms-current-block-${formId}`, currentBlockId, {
        expires: 30
      }, {
        path: '/'
      });
    }
  }, [currentBlockId, answers]);
  const isTouchScreen = typeof window !== 'undefined' && 'ontouchstart' in window || typeof navigator !== 'undefined' && navigator.maxTouchPoints > 0 ||
  // @ts-expect-error
  typeof navigator !== 'undefined' && navigator.msMaxTouchPoints > 0;
  const getFieldsToRender = () => {
    const fieldIds = [];
    const filteredBlocks = walkPath.filter(block => answers[block.id]?.isPending || block.id === currentBlockId || !isTouchScreen && block.id === nextBlockId || !isTouchScreen && block.id === prevBlockId || !isTouchScreen && block.id === lastActiveBlockId);
    filteredBlocks.forEach(block => {
      if (block.name !== 'welcome-screen' && block.name !== 'thankyou-screen') {
        fieldIds.push(block.id);
      }
    });
    return fieldIds;
  };
  const fieldsToRender = getFieldsToRender();
  const fields = walkPath.filter(block => block.name !== 'welcome-screen' && block.name !== 'thankyou-screen');
  const goNextReally = async () => {
    if (answers[currentBlockIndex]?.isPending) return;
    if (beforeGoingNext && currentBlockId) {
      await beforeGoingNext({
        answers,
        currentBlockId,
        setIsFieldValid,
        setFieldValidationErr,
        setIsCurrentBlockSafeToSwipe,
        goToBlock,
        goNext,
        setIsPending: val => setIsFieldPending(currentBlockId, val)
      });
    } else {
      if (correctIncorrectQuiz?.enabled && swiper?.correctIncorrectDisplay === false && currentBlockType.supports.correctAnswers && correctIncorrectQuiz?.showAnswersDuringQuiz && !answers[currentBlockId]?.isCorrectIncorrectScreenDisplayed) {
        setCorrectIncorrectDisplay(true);
        setIsFieldCorrectIncorrectScreenDisplayed(currentBlockId, true);
        return;
      }
      goNext();
    }
  };
  const {
    isCurrentBlockValid
  } = useSelect(select => {
    return {
      isCurrentBlockValid: currentBlockType?.supports?.innerBlocks ? select('quillForms/renderer-core')?.hasValidFields(
      // @ts-expect-error
      currentBlockId) : currentBlockType?.supports?.editable ? select('quillForms/renderer-core')?.isValidField(
      // @ts-expect-error
      currentBlockId) : true
    };
  });
  useEffect(() => {
    if (isCurrentBlockSafeToSwipe) setIsCurrentBlockSafeToSwipe(true);
  }, [isCurrentBlockValid]);
  const isFirstField = walkPath?.length > 0 && walkPath[0].id === currentBlockId;
  const isLastField = walkPath?.length && currentBlockId === walkPath[walkPath.length - 1].id;
  const handlers = useSwipeable({
    onSwiping: e => {
      swipingHandler(e, true);
    },
    preventDefaultTouchmoveEvent: false,
    trackMouse: false,
    trackTouch: true,
    delta: 70
  });

  // Mouse Wheel Handler
  const swipingHandler = (e, touch = false) => {
    if (settings?.disableWheelSwiping) return;
    let delta = e.deltaY;
    if (settings?.animationDirection === 'horizontal') {
      delta = e.deltaX;
    }
    if (swiper.isAnimating) return;
    const lethargyCheck = lethargy.check(e);
    const now = new Date().getTime();
    let timeDelay = 900;
    if (touch) timeDelay = 500;
    if (lethargyCheck === false || isAnimating || lastScrollDate && now - lastScrollDate < timeDelay) return;
    if (canSwipePrev && (delta < -50 && !touch || touch && delta > 50 && e.dir === 'Down') && !isFirstField) {
      // Scroll up
      lastScrollDate = new Date().getTime();
      goPrev();
    } else if (canSwipeNext && (delta < -50 && touch && e.dir === 'Up' || !touch && delta > 50) && !isLastField) {
      lastScrollDate = new Date().getTime();
      // Scroll down
      if (isCurrentBlockValid) {
        goNextReally();
      } else {
        setIsCurrentBlockSafeToSwipe(false);
      }
    }
  };
  useEffect(() => {
    if (isAnimating) {
      const timer = setTimeout(() => {
        setSwiper({
          isAnimating: false
        });
      }, 600);
      return () => clearTimeout(timer);
    }
  }, [swiper]);
  useEffect(() => {
    if (applyLogic && isActive) {
      doAction('QuillForms.RendererCore.LogicApply', blocks, blockTypes, logic, hiddenFields);
    }
  }, [answers, currentBlockId]);
  useEffect(() => {
    if (applyLogic && isActive) {
      setSwiper({
        currentBlockId: blocks[0].id,
        prevBlockId: undefined,
        canSwipePrev: false,
        lastActiveBlockId: undefined
      });
      doAction('QuillForms.RendererCore.LogicApply', blocks, blockTypes, logic, hiddenFields);
    }
    if (!applyLogic) {
      doAction('QuillForms.RendererCore.LogicTurnOff');
    }
  }, [applyLogic]);

  // const isThereNextField =
  // 	fields.filter( ( field ) => field.id === nextBlockId ).length === 0;

  const handleNext = () => {
    if (isCurrentBlockValid) {
      goNextReally();
    } else {
      setIsCurrentBlockSafeToSwipe(false);
    }
  };
  return createElement("div", {
    onWheel: swipingHandler,
    className: classNames('renderer-core-fields-wrapper', {
      active: isActive,
      'is-moving-up': isAnimating && currentBlockIndex < lastActiveBlockIndex,
      'is-moving-down': isAnimating && currentBlockIndex > lastActiveBlockIndex
    }),
    ref: ref,
    "aria-hidden": isActive ? false : true
  }, createElement("div", {
    ...handlers
  }, fields.map((field, index) => {
    const isActive = currentBlockId === field.id;
    return createElement(FieldRender, {
      key: `${field.id}`,
      id: field.id,
      shouldBeRendered: fieldsToRender.includes(field.id),
      isActive: isActive,
      isCurrentBlockSafeToSwipe: isActive ? isCurrentBlockSafeToSwipe : true,
      isLastField: (!nextBlock || nextBlock.name === 'thankyou-screen') && index === fields.length - 1,
      next: () => handleNext()
    });
  })));
};
export default FieldsWrapper;
//# sourceMappingURL=index.js.map