"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _useBlockTheme = _interopRequireDefault(require("../../hooks/use-block-theme"));
var _element = require("@wordpress/element");
var _data = require("@wordpress/data");
var _classnames = _interopRequireDefault(require("classnames"));
var _emotion = require("emotion");
var _context = require("../field-render/context");
var _fieldContent = _interopRequireDefault(require("../field-content"));
var _lodash = require("lodash");
var _useFormSettings = _interopRequireDefault(require("../../hooks/use-form-settings"));
var _fieldAttachment = _interopRequireDefault(require("../field-attachment"));
var _hooks = require("../../hooks");
/* eslint-disable no-nested-ternary */
/**
 * QuillForms Dependencies
 */

/**
 * WordPress Dependencies
 */

/**
 * External Dependencies
 */

/**
 * Internal Dependencies
 */

let scrollTimer;
let tabTimer;
const FieldWrapper = () => {
  var _attributes$layout, _attributes$classname;
  const {
    id,
    isActive,
    shouldBeRendered,
    showErrMsg,
    next,
    attributes,
    blockName
  } = (0, _context.__experimentalUseFieldRenderContext)();
  const {
    deviceWidth
  } = (0, _hooks.useFormContext)();
  const correctIncorrectQuiz = (0, _hooks.useCorrectIncorrectQuiz)();
  const settings = (0, _useFormSettings.default)();
  if (!id || !blockName) return null;
  const {
    blockType
  } = (0, _data.useSelect)(select => {
    return {
      blockType: select('quillForms/blocks').getBlockType(blockName)
    };
  });
  if (!blockType) return null;
  const {
    swiper,
    isValid,
    isFocused
  } = (0, _data.useSelect)(select => {
    return {
      swiper: select('quillForms/renderer-core').getSwiperState(),
      isValid: blockType?.supports?.innerBlocks ? select('quillForms/renderer-core').hasValidFields(id) : blockType?.supports?.editable ? select('quillForms/renderer-core').isValidField(id) : true,
      isFocused: select('quillForms/renderer-core').isFocused()
    };
  });
  const {
    setSwiper,
    goPrev,
    setIsCurrentBlockSafeToSwipe,
    setIsFieldAnswerLocked,
    setCorrectIncorrectDisplay,
    goNext,
    setFooterDisplay
  } = (0, _data.useDispatch)('quillForms/renderer-core');
  const {
    correctIncorrectDisplay
  } = (0, _data.useSelect)(select => {
    return {
      correctIncorrectDisplay: select('quillForms/renderer-core').getCorrectIncorrectDisplay()
    };
  });
  (0, _element.useEffect)(() => {
    if (correctIncorrectDisplay) {
      if (currentBlockId) setIsFieldAnswerLocked(currentBlockId, true);
      setTimeout(() => {
        setCorrectIncorrectDisplay(false);
      }, 1000);
      setTimeout(() => {
        if ((0, _lodash.size)(correctIncorrectQuiz?.questions?.[currentBlockId]?.explanation) <= 0) {
          goNext();
        }
      }, 1450);
    }
  }, [correctIncorrectDisplay]);
  const {
    walkPath,
    currentBlockId,
    isAnimating,
    isReviewing
  } = swiper;
  const setCanSwipeNext = val => {
    // if ( walkPath[ walkPath.length - 1 ].id === id ) val = false;
    setSwiper({
      canSwipeNext: val
    });
  };
  const setCanSwipePrev = val => {
    setSwiper({
      canSwipePrev: val
    });
  };
  const fieldIndex = walkPath.findIndex(field => field.id === id);
  const currentFieldIndex = walkPath.findIndex($field => $field.id === currentBlockId);
  const position = isActive ? null : currentFieldIndex > fieldIndex ? 'is-up' : 'is-down';
  const ref = (0, _element.useRef)(null);
  (0, _element.useEffect)(() => {
    if (isActive && !isReviewing) {
      setTimeout(() => {
        setIsCurrentBlockSafeToSwipe(true);
      }, 40);
    }
  }, [isActive, isReviewing]);
  (0, _element.useEffect)(() => {
    if (isActive) {
      if (ref?.current) {
        setTimeout(() => {
          if (ref?.current) {
            ref.current.scrollTo(0, 0);
          }
          setCanSwipePrev(true);
        }, 0);
      }
    } else {
      clearTimeout(tabTimer);
      clearTimeout(scrollTimer);
      setCanSwipeNext(true);
      setCanSwipePrev(true);
    }
  }, [isActive]);
  (0, _element.useEffect)(() => {
    if (isAnimating) clearTimeout(tabTimer);
  }, [isAnimating]);
  const focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex="0"], [contenteditable]';

  /**
   * Gets all the focusable elements inside the passed element.
   *
   * @param  el
   */
  function getFocusables(el) {
    return (0, _lodash.filter)(Array.prototype.slice.call(document.querySelector(el).querySelectorAll(focusableElementsString)), item => {
      return item.getAttribute('tabindex') !== '-1' &&
      //are also not hidden elements (or with hidden parents)
      item.offsetParent !== null && window.getComputedStyle(item).visibility !== 'hidden';
    });
  }
  function processTab(isShiftPressed) {
    if (isAnimating) {
      return;
    }
    const activeElement = document.activeElement;
    const focusableElements = getFocusables(`#block-${id}`);
    //outside the block? Let's not hijack the tab!
    if (!isFocused) {
      return;
    }
    const activeElementIndex = (0, _lodash.findIndex)(focusableElements, el => el === activeElement);

    // Happens when the active element is in the next block or previous block
    // This case occurs when pressing tab multiple times at the same time.
    if (activeElementIndex === -1) {
      return;
    }
    if (!isShiftPressed) {
      if (activeElement == focusableElements[focusableElements.length - 1]) {
        next();
      } else if (focusableElements[activeElementIndex + 1].offsetParent !== null &&
      // If document element is still in dom
      // One example for this case is  the next button in each block if the block isn't valid and the error message
      // appear instead of the button. The button is focusable but it is no longer in dom.
      document.contains(focusableElements[activeElementIndex + 1])) {
        focusableElements[activeElementIndex + 1].focus();
      } else {
        //when reached the last focusable element of the block, go next
        next();
      }
    } else {
      //when reached the first  focusable element of the block, go prev if shift is pressed
      if (activeElementIndex === 0) {
        goPrev();
      } else if (activeElementIndex === -1) {
        document.body.focus();
      } else {
        focusableElements[activeElementIndex - 1].focus();
      }
    }
  }

  /**
   * Makes sure the tab key will only focus elements within the current block  preventing this way from breaking the page.
   * Otherwise, go next or prev.
   *
   * @param  e
   * @param  isShiftPressed
   */
  function onTab(e, isShiftPressed) {
    clearTimeout(tabTimer);
    if (isAnimating) return;
    e.preventDefault();
    tabTimer = setTimeout(() => {
      processTab(isShiftPressed);
    }, 150);
  }
  const scrollHandler = e => {
    if (settings?.disableWheelSwiping || settings?.animationDirection === 'horizontal') {
      return;
    }
    e.preventDefault();
    if (!ref.current) return;
    if (ref.current.scrollTop <= 0) {
      scrollTimer = setTimeout(() => {
        setCanSwipePrev(true);
      }, 500);
    } else {
      setCanSwipePrev(false);
    }
    // Adding tolerance to detect scroll end.
    // It was a problem with mobile devices.
    if (Math.abs(ref.current.scrollHeight - ref.current.clientHeight - ref.current.scrollTop) <= 3.0) {
      scrollTimer = setTimeout(() => {
        setCanSwipeNext(true);
      }, 500);
    } else {
      setCanSwipeNext(false);
    }
  };
  const isTouchScreen = typeof window !== 'undefined' && 'ontouchstart' in window || typeof navigator !== 'undefined' && navigator.maxTouchPoints > 0 ||
  // @ts-expect-error
  typeof navigator !== 'undefined' && navigator.msMaxTouchPoints > 0;
  const layout = blockType?.displayLayout && blockType?.displayLayout !== 'default' ? blockType.displayLayout : (_attributes$layout = attributes?.layout) !== null && _attributes$layout !== void 0 ? _attributes$layout : 'stack';
  const theme = (0, _useBlockTheme.default)(attributes?.themeId);
  let backgroundImageCSS = '';
  if (theme.backgroundImage && theme.backgroundImage) {
    backgroundImageCSS = `background-image: url('${theme.backgroundImage}');
			background-size: cover;
			background-position: ${
    // @ts-expect-error
    parseFloat(theme.backgroundImageFocalPoint?.x) * 100}%
			${
    // @ts-expect-error
    parseFloat(theme.backgroundImageFocalPoint?.y) * 100}%;
		`;
  }
  let specialProps = {};
  if (isActive) {
    specialProps = {
      'data-iframe-height': true
    };
  }
  return (0, _react.createElement)("div", {
    className: (0, _classnames.default)('renderer-components-field-wrapper', {
      active: isActive,
      'is-animating': isAnimating,
      'is-horizontal-animation': settings?.animationDirection === 'horizontal'
    }, `${(_attributes$classname = attributes?.classnames) !== null && _attributes$classname !== void 0 ? _attributes$classname : ''}`, `${theme.typographyPreset}-typography-preset`, position ? position : '', (0, _emotion.css)`
					font-family: ${theme.font};
					@media ( min-width: 768px ) {
						font-size: ${theme.fontSize.lg};
						line-height: ${theme.fontLineHeight.lg};
					}
					@media ( max-width: 767px ) {
						font-size: ${theme.fontSize.sm};
						line-height: ${theme.fontLineHeight.sm};
					}
					textarea,
					input {
						font-family: ${theme.font};
						background: transparent;
						background-color: transparent;

						@media ( min-width: 768px ) {
							font-size: ${theme.textInputAnswers.lg};
							line-height: ${theme.textInputAnswers.lg};
						}
						@media ( max-width: 767px ) {
							font-size: ${theme.textInputAnswers.sm};
							line-height: ${theme.textInputAnswers.sm};
						}
					}
					${attributes?.themeId && backgroundImageCSS}
				`)
  }, (0, _react.createElement)("div", {
    className: (0, _emotion.css)`
					${attributes?.themeId && `background: ${theme.backgroundColor}`};
					width: 100%;
					height: 100%;
				`
  }, shouldBeRendered && (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)("section", {
    id: 'block-' + id,
    className: (0, _classnames.default)(`blocktype-${blockName}-block`, `renderer-core-block-${layout}-layout`, {
      'with-attachment': blockType?.supports.attachment
    })
  }, (0, _react.createElement)("div", {
    className: "renderer-components-field-wrapper__content-wrapper renderer-components-block__content-wrapper",
    tabIndex: 0
    // @ts-expect-error
    ,
    onKeyDown: e => {
      const isShiftPressed = e.shiftKey;
      if (isAnimating) {
        e.preventDefault();
        return;
      }
      if (e.key === 'Enter') {
        if (isTouchScreen) {
          setFooterDisplay(true);
        }
        if (isValid) {
          next();
        } else {
          showErrMsg(true);
        }
      } else {
        //tab?
        if (e.key === 'Tab') {
          e.stopPropagation();
          e.preventDefault();
          onTab(e, isShiftPressed);
        }
      }
    }
  }, (0, _react.createElement)("div", {
    ref: ref,
    ...specialProps,
    className: "renderer-core-block-scroller",
    onScroll: e => scrollHandler(e)
  }, (0, _react.createElement)(_fieldContent.default, null))), (layout !== 'stack' && deviceWidth !== 'mobile' || deviceWidth === 'mobile' && (layout === 'split-left' || layout === 'split-right')) && blockType?.supports?.attachment && (0, _react.createElement)("div", {
    className: (0, _classnames.default)('renderer-core-block-attachment-wrapper', (0, _emotion.css)`
											img {
												object-position: ${
    // @ts-expect-error
    attributes?.attachmentFocalPoint?.x * 100}%
													${
    // @ts-expect-error
    attributes?.attachmentFocalPoint?.y * 100}%;
											}
										`)
  }, (0, _react.createElement)(_fieldAttachment.default, null))))));
};
var _default = exports.default = FieldWrapper;
//# sourceMappingURL=index.js.map