"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _autop = require("@wordpress/autop");
var _icons = require("@wordpress/icons");
var _components = require("@wordpress/components");
var _lodash = require("lodash");
var _classnames = _interopRequireDefault(require("classnames"));
var _slate = require("slate");
var _slateReact = require("slate-react");
var _createEditor = _interopRequireDefault(require("../../create-editor"));
var _htmlDeserialize = _interopRequireDefault(require("../../html-deserialize"));
var _htmlSerialize = _interopRequireDefault(require("../../html-serialize"));
var _editor = _interopRequireDefault(require("../editor"));
/**
 * WordPress Dependencies
 */

/**
 * External Dependencies
 */

/**
 * Internal Dependencies
 */

const RichTextControlRenderer = ({
  id,
  value,
  setValue,
  mergeTags,
  className,
  allowedFormats,
  focusOnMount = false,
  placeholder
}) => {
  const [isReady, setIsReady] = (0, _react.useState)(false);
  const [jsonVal, setJsonVal] = (0, _react.useState)([{
    type: 'paragraph',
    children: [{
      text: ''
    }]
  }]);
  const [currentSelection, setCurrentSelection] = (0, _react.useState)({
    path: [0, 0],
    offset: 0
  });
  const editor = (0, _react.useMemo)(() => (0, _createEditor.default)(), [id, isReady]);
  const isMounted = (0, _react.useRef)(false);
  (0, _react.useEffect)(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);

  // serializeVal is a debounced function that updates the store with serialized html value
  const serializeVal = (0, _react.useCallback)((0, _lodash.debounce)(newVal => {
    if (isMounted.current) {
      setValue((0, _htmlSerialize.default)(newVal));
    }
  }, 200), []);
  const onChange = newVal => {
    if (editor.selection) {
      setCurrentSelection({
        path: editor.selection.focus.path,
        offset: editor.selection.focus.offset
      });
    }
    setJsonVal(newVal);
    serializeVal(newVal);
  };

  // Deserialize value on mount.
  (0, _react.useEffect)(() => {
    if (focusOnMount) {
      setTimeout(() => {
        _slateReact.ReactEditor.focus(editor);
      }, 0);
    }
  }, []);
  (0, _react.useEffect)(() => {
    setIsReady(false);
    setJsonVal((0, _htmlDeserialize.default)((0, _autop.autop)(value)));
    setIsReady(true);
  }, [mergeTags?.length]);
  const TextEditor = (0, _react.useMemo)(() => (0, _react.createElement)(_editor.default, {
    value: jsonVal,
    editor: editor,
    onChange: onChange,
    mergeTags: mergeTags,
    onFocus: () => {
      if (editor.selection) {
        setCurrentSelection({
          path: editor.selection.focus.path,
          offset: editor.selection.focus.offset
        });
      }
    },
    allowedFormats: allowedFormats,
    placeholder: placeholder
  }), [isReady, JSON.stringify(jsonVal), JSON.stringify(mergeTags)]);
  if (!isReady) return null;
  return (0, _react.createElement)("div", {
    className: (0, _classnames.default)('rich-text-control', className)
  }, (0, _react.createElement)(_react.Fragment, null, TextEditor, mergeTags && mergeTags.length > 0 && (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)("div", {
    className: "rich-text-control__add-merge-tags"
  }, (0, _react.createElement)(_components.Icon, {
    icon: _icons.plusCircle
    // @ts-expect-error
    ,
    onClick: e => {
      e.stopPropagation();
      _slate.Transforms.insertText(editor, '@', {
        at: currentSelection
      });
      setTimeout(() => {
        _slate.Transforms.select(editor, currentSelection);
        _slateReact.ReactEditor.focus(editor);
        _slate.Transforms.move(editor, {
          unit: 'character'
        });
      }, 0);
    }
  })))));
};
var _default = exports.default = RichTextControlRenderer;
//# sourceMappingURL=renderer.js.map