"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _components = require("@wordpress/components");
var _slate = require("slate");
var _slateReact = require("slate-react");
var _emotion = require("emotion");
var _element = _interopRequireDefault(require("../element"));
var _hoveringToolbar = _interopRequireDefault(require("../hovering-toolbar"));
var _mergeTagListItem = _interopRequireDefault(require("../merge-tag-list-item"));
/* eslint-disable no-nested-ternary */
/**
 * WordPress Dependencies
 */

/**
 * External Dependencies
 */

/**
 * Internal Dependencies
 */

const TextEditor = props => {
  const {
    editor,
    placeholder,
    color,
    onChange,
    value,
    onFocus,
    mergeTags = [],
    // mergeTagsSections = [
    // 	{ key: 'field', label: 'Fields' },
    // 	{ key: 'variable', label: 'Variables' },
    // 	{ key: 'hidden_field', label: 'Hidden Fields' },
    // ],
    allowedFormats = []
  } = props;
  const wrapperRef = (0, _react.useRef)(null);
  const PopoverRef = (0, _react.useRef)(null);
  const ref = (0, _react.useRef)(null);
  const [target, setTarget] = (0, _react.useState)();
  const [index, setIndex] = (0, _react.useState)(0);
  const [search, setSearch] = (0, _react.useState)('');
  const $mergeTags = mergeTags.filter(c => {
    if (search) {
      return c.label?.toLowerCase().startsWith(search ? search.toLowerCase() : '');
    }
    return true;
  });
  const isFormatActive = format => {
    const [match] = _slate.Editor.nodes(editor, {
      match: n => n[format] === true,
      mode: 'all'
    });
    return !!match;
  };
  const renderElement = (0, _react.useCallback)(props => {
    return (0, _react.createElement)(_element.default, {
      ...props,
      editor: editor,
      mergeTags: mergeTags
    });
  }, [mergeTags, value]);
  const toggleFormat = (editor, format) => {
    const active = isFormatActive(format);
    _slate.Transforms.setNodes(editor, {
      [format]: active ? null : true
    }, {
      match: _slate.Text.isText,
      split: true
    });
  };
  const Leaf = ({
    attributes,
    children,
    leaf
  }) => {
    if (leaf.bold) {
      children = (0, _react.createElement)("strong", null, children);
    }
    if (leaf.italic) {
      children = (0, _react.createElement)("em", null, children);
    }
    return (0, _react.createElement)("span", {
      ...attributes
    }, children);
  };

  // Insert Variable
  const insertMergeTag = mergeTag => {
    _slate.Transforms.insertNodes(editor, {
      type: 'mergeTag',
      data: {
        type: mergeTag.type,
        modifier: mergeTag.modifier
      },
      children: [{
        text: ''
      }]
    });
    setTimeout(() => {
      _slate.Transforms.move(editor);
    }, 0);
  };
  const onKeyDown = (0, _react.useCallback)(event => {
    if (event.key === 'Enter' && allowedFormats?.length === 0) {
      event.preventDefault();
    }
    if (target) {
      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();
          const prevIndex = index >= $mergeTags.length - 1 ? 0 : index + 1;
          setIndex(prevIndex);
          break;
        case 'ArrowUp':
          event.preventDefault();
          const nextIndex = index <= 0 ? $mergeTags.length - 1 : index - 1;
          setIndex(nextIndex);
          break;
        case 'Tab':
        case 'Enter':
          event.preventDefault();
          _slate.Transforms.select(editor, target);
          insertMergeTag($mergeTags[index]);
          setTarget(undefined);
          break;
        case 'Escape':
          event.preventDefault();
          setTarget(undefined);
          break;
      }
    }
  }, [index, search, target]);

  // useEffect( () => {
  // 	if ( target && $mergeTags.length > 0 ) {
  // 		const el: HTMLDivElement | null = ref.current;
  // 		const domRange = ReactEditor.toDOMRange( editor, target );
  // 		const rect = domRange.getBoundingClientRect();
  // 		if ( el ) {
  // 			el.style.top = `${ rect.top + window.pageYOffset + 24 }px`;
  // 			el.style.left = `${ rect.left + window.pageXOffset }px`;
  // 		}
  // 	}
  // }, [ $mergeTags.length, editor, index, search, target ] );

  (0, _react.useEffect)(() => {
    /**
     * Alert if clicked on outside of element
     *
     * @param  event
     */
    function handleClickOutsidePortal(event) {
      if (PopoverRef.current && ref.current &&
      // @ts-expect-error
      !PopoverRef.current.contains(event.target) && !ref.current.contains(event.target)) {
        setTarget(undefined);
      }
    }

    // Bind the event listener
    document.addEventListener('mousedown', handleClickOutsidePortal);
    return () => {
      // Unbind the event listener on clean up
      document.removeEventListener('mousedown', handleClickOutsidePortal);
    };
  }, [PopoverRef]);
  return (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)("div", {
    className: "richtext__editor",
    style: {
      width: '100%'
    },
    ref: wrapperRef
  }, (0, _react.createElement)(_slateReact.Slate, {
    editor: editor,
    initialValue: value,
    onChange: val => {
      onChange(val);
      const {
        selection
      } = editor;
      if (selection && _slate.Range.isCollapsed(selection)) {
        const [start] = _slate.Range.edges(selection);
        const wordBefore = selection;
        const before = wordBefore && _slate.Editor.before(editor, wordBefore);
        const beforeRange = before && _slate.Editor.range(editor, before, start);
        const beforeText = beforeRange && _slate.Editor.string(editor, beforeRange);
        const beforeMatch = beforeText && beforeText.endsWith('@');
        const after = _slate.Editor.after(editor, start);
        const afterRange = _slate.Editor.range(editor, start, after);
        const afterText = _slate.Editor.string(editor, afterRange);
        const afterMatch = afterText.match(/^(\s|$)/);
        if (beforeMatch && afterMatch) {
          setTarget(beforeRange);
          setSearch(beforeMatch[1]);
          setIndex(0);
        } else {
          setTarget(undefined);
        }
      }
    }
  }, allowedFormats?.length > 0 && (0, _react.createElement)(_hoveringToolbar.default, {
    formattingControls: allowedFormats,
    toggleFormat: format => toggleFormat(editor, format),
    isFormatActive: format => isFormatActive(format)
  }), (0, _react.createElement)(_slateReact.Editable, {
    style: {
      color
    },
    color: color,
    renderLeaf: $props => (0, _react.createElement)(Leaf, {
      ...$props
    }),
    renderElement: renderElement,
    renderPlaceholder: ({
      attributes,
      children
    }) => (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)("div", {
      ...attributes,
      style: {
        opacity: 0,
        height: 0,
        position: "relative",
        zIndex: -1
      }
    }, children), (0, _react.createElement)("div", {
      ...attributes
    }, children)),
    placeholder: placeholder,
    onFocus: onFocus,
    onKeyDown: onKeyDown,
    onDOMBeforeInput: event => {
      switch (event.inputType) {
        case 'formatBold':
          return toggleFormat(editor, 'bold');
        case 'formatItalic':
          return toggleFormat(editor, 'italic');
      }
    }
  }), target && $mergeTags.length > 0 && (0, _react.createElement)(_components.Popover, {
    ref: PopoverRef,
    className: (0, _emotion.css)`
								z-index: 1111111111111111111;
								.components-popover__content {
									padding: 3px;
									border: none;
									border-radius: 4px;
									box-shadow: 0 1px 5px rgba( 0, 0, 0, 0.2 );
									z-index: 111111111111111111;
								}
							`,
    onKeyDown: onKeyDown
  }, (0, _react.createElement)("div", {
    className: (0, _emotion.css)`
									padding: 5px 25px;
									font-weight: bold;
								`
  }, "Recall Information from..."), (0, _react.createElement)("div", {
    className: "rich-text-merge-tag-list",
    ref: ref
  }, $mergeTags.map((mergeTag, i) => (0, _react.createElement)(_mergeTagListItem.default, {
    key: `merge-tag-${i}`,
    mergeTag: mergeTag,
    onClick: () => {
      _slate.Transforms.select(editor, target);
      insertMergeTag(mergeTag);
      _slateReact.ReactEditor.focus(editor);
    },
    onMouseEnter: () => setIndex(i),
    isSelected: index === i
  })))))));
};

/**
 * Export.
 */
var _default = exports.default = TextEditor;
//# sourceMappingURL=index.js.map