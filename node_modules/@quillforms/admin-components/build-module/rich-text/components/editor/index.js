import { createElement } from "react";
/* eslint-disable no-nested-ternary */
/**
 * WordPress Dependencies
 */
import { Fragment, useCallback, useEffect, useState, useRef } from 'react';
import { Popover } from '@wordpress/components';

/**
 * External Dependencies
 */
import { Transforms, Text, Editor, Range } from 'slate';
import { Slate, Editable, ReactEditor } from 'slate-react';
import { css } from 'emotion';

/**
 * Internal Dependencies
 */
import Element from '../element';
import HoveringToolbar from '../hovering-toolbar';
import MergeTagListItem from '../merge-tag-list-item';
const TextEditor = props => {
  const {
    editor,
    placeholder,
    color,
    onChange,
    value,
    onFocus,
    mergeTags = [],
    // mergeTagsSections = [
    // 	{ key: 'field', label: 'Fields' },
    // 	{ key: 'variable', label: 'Variables' },
    // 	{ key: 'hidden_field', label: 'Hidden Fields' },
    // ],
    allowedFormats = []
  } = props;
  const wrapperRef = useRef(null);
  const PopoverRef = useRef(null);
  const ref = useRef(null);
  const [target, setTarget] = useState();
  const [index, setIndex] = useState(0);
  const [search, setSearch] = useState('');
  const $mergeTags = mergeTags.filter(c => {
    if (search) {
      return c.label?.toLowerCase().startsWith(search ? search.toLowerCase() : '');
    }
    return true;
  });
  const isFormatActive = format => {
    const [match] = Editor.nodes(editor, {
      match: n => n[format] === true,
      mode: 'all'
    });
    return !!match;
  };
  const renderElement = useCallback(props => {
    return createElement(Element, {
      ...props,
      editor: editor,
      mergeTags: mergeTags
    });
  }, [mergeTags, value]);
  const toggleFormat = (editor, format) => {
    const active = isFormatActive(format);
    Transforms.setNodes(editor, {
      [format]: active ? null : true
    }, {
      match: Text.isText,
      split: true
    });
  };
  const Leaf = ({
    attributes,
    children,
    leaf
  }) => {
    if (leaf.bold) {
      children = createElement("strong", null, children);
    }
    if (leaf.italic) {
      children = createElement("em", null, children);
    }
    return createElement("span", {
      ...attributes
    }, children);
  };

  // Insert Variable
  const insertMergeTag = mergeTag => {
    Transforms.insertNodes(editor, {
      type: 'mergeTag',
      data: {
        type: mergeTag.type,
        modifier: mergeTag.modifier
      },
      children: [{
        text: ''
      }]
    });
    setTimeout(() => {
      Transforms.move(editor);
    }, 0);
  };
  const onKeyDown = useCallback(event => {
    if (event.key === 'Enter' && allowedFormats?.length === 0) {
      event.preventDefault();
    }
    if (target) {
      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();
          const prevIndex = index >= $mergeTags.length - 1 ? 0 : index + 1;
          setIndex(prevIndex);
          break;
        case 'ArrowUp':
          event.preventDefault();
          const nextIndex = index <= 0 ? $mergeTags.length - 1 : index - 1;
          setIndex(nextIndex);
          break;
        case 'Tab':
        case 'Enter':
          event.preventDefault();
          Transforms.select(editor, target);
          insertMergeTag($mergeTags[index]);
          setTarget(undefined);
          break;
        case 'Escape':
          event.preventDefault();
          setTarget(undefined);
          break;
      }
    }
  }, [index, search, target]);

  // useEffect( () => {
  // 	if ( target && $mergeTags.length > 0 ) {
  // 		const el: HTMLDivElement | null = ref.current;
  // 		const domRange = ReactEditor.toDOMRange( editor, target );
  // 		const rect = domRange.getBoundingClientRect();
  // 		if ( el ) {
  // 			el.style.top = `${ rect.top + window.pageYOffset + 24 }px`;
  // 			el.style.left = `${ rect.left + window.pageXOffset }px`;
  // 		}
  // 	}
  // }, [ $mergeTags.length, editor, index, search, target ] );

  useEffect(() => {
    /**
     * Alert if clicked on outside of element
     *
     * @param  event
     */
    function handleClickOutsidePortal(event) {
      if (PopoverRef.current && ref.current &&
      // @ts-expect-error
      !PopoverRef.current.contains(event.target) && !ref.current.contains(event.target)) {
        setTarget(undefined);
      }
    }

    // Bind the event listener
    document.addEventListener('mousedown', handleClickOutsidePortal);
    return () => {
      // Unbind the event listener on clean up
      document.removeEventListener('mousedown', handleClickOutsidePortal);
    };
  }, [PopoverRef]);
  return createElement(Fragment, null, createElement("div", {
    className: "richtext__editor",
    style: {
      width: '100%'
    },
    ref: wrapperRef
  }, createElement(Slate, {
    editor: editor,
    initialValue: value,
    onChange: val => {
      onChange(val);
      const {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        const [start] = Range.edges(selection);
        const wordBefore = selection;
        const before = wordBefore && Editor.before(editor, wordBefore);
        const beforeRange = before && Editor.range(editor, before, start);
        const beforeText = beforeRange && Editor.string(editor, beforeRange);
        const beforeMatch = beforeText && beforeText.endsWith('@');
        const after = Editor.after(editor, start);
        const afterRange = Editor.range(editor, start, after);
        const afterText = Editor.string(editor, afterRange);
        const afterMatch = afterText.match(/^(\s|$)/);
        if (beforeMatch && afterMatch) {
          setTarget(beforeRange);
          setSearch(beforeMatch[1]);
          setIndex(0);
        } else {
          setTarget(undefined);
        }
      }
    }
  }, allowedFormats?.length > 0 && createElement(HoveringToolbar, {
    formattingControls: allowedFormats,
    toggleFormat: format => toggleFormat(editor, format),
    isFormatActive: format => isFormatActive(format)
  }), createElement(Editable, {
    style: {
      color
    },
    color: color,
    renderLeaf: $props => createElement(Leaf, {
      ...$props
    }),
    renderElement: renderElement,
    renderPlaceholder: ({
      attributes,
      children
    }) => createElement(Fragment, null, createElement("div", {
      ...attributes,
      style: {
        opacity: 0,
        height: 0,
        position: "relative",
        zIndex: -1
      }
    }, children), createElement("div", {
      ...attributes
    }, children)),
    placeholder: placeholder,
    onFocus: onFocus,
    onKeyDown: onKeyDown,
    onDOMBeforeInput: event => {
      switch (event.inputType) {
        case 'formatBold':
          return toggleFormat(editor, 'bold');
        case 'formatItalic':
          return toggleFormat(editor, 'italic');
      }
    }
  }), target && $mergeTags.length > 0 && createElement(Popover, {
    ref: PopoverRef,
    className: css`
								z-index: 1111111111111111111;
								.components-popover__content {
									padding: 3px;
									border: none;
									border-radius: 4px;
									box-shadow: 0 1px 5px rgba( 0, 0, 0, 0.2 );
									z-index: 111111111111111111;
								}
							`,
    onKeyDown: onKeyDown
  }, createElement("div", {
    className: css`
									padding: 5px 25px;
									font-weight: bold;
								`
  }, "Recall Information from..."), createElement("div", {
    className: "rich-text-merge-tag-list",
    ref: ref
  }, $mergeTags.map((mergeTag, i) => createElement(MergeTagListItem, {
    key: `merge-tag-${i}`,
    mergeTag: mergeTag,
    onClick: () => {
      Transforms.select(editor, target);
      insertMergeTag(mergeTag);
      ReactEditor.focus(editor);
    },
    onMouseEnter: () => setIndex(i),
    isSelected: index === i
  })))))));
};

/**
 * Export.
 */
export default TextEditor;
//# sourceMappingURL=index.js.map