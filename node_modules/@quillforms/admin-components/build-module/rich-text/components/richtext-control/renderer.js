import { createElement } from "react";
/**
 * WordPress Dependencies
 */
import { useMemo, useCallback, useEffect, useState, useRef, Fragment } from 'react';
import { autop } from '@wordpress/autop';
import { plusCircle } from '@wordpress/icons';
import { Icon } from '@wordpress/components';

/**
 * External Dependencies
 */
import { debounce } from 'lodash';
import classnames from 'classnames';
import { Transforms } from 'slate';
import { ReactEditor } from 'slate-react';

/**
 * Internal Dependencies
 */
import createEditor from '../../create-editor';
import deserialize from '../../html-deserialize';
import serialize from '../../html-serialize';
import RichTextEditor from '../editor';
const RichTextControlRenderer = ({
  id,
  value,
  setValue,
  mergeTags,
  className,
  allowedFormats,
  focusOnMount = false,
  placeholder
}) => {
  const [isReady, setIsReady] = useState(false);
  const [jsonVal, setJsonVal] = useState([{
    type: 'paragraph',
    children: [{
      text: ''
    }]
  }]);
  const [currentSelection, setCurrentSelection] = useState({
    path: [0, 0],
    offset: 0
  });
  const editor = useMemo(() => createEditor(), [id, isReady]);
  const isMounted = useRef(false);
  useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);

  // serializeVal is a debounced function that updates the store with serialized html value
  const serializeVal = useCallback(debounce(newVal => {
    if (isMounted.current) {
      setValue(serialize(newVal));
    }
  }, 200), []);
  const onChange = newVal => {
    if (editor.selection) {
      setCurrentSelection({
        path: editor.selection.focus.path,
        offset: editor.selection.focus.offset
      });
    }
    setJsonVal(newVal);
    serializeVal(newVal);
  };

  // Deserialize value on mount.
  useEffect(() => {
    if (focusOnMount) {
      setTimeout(() => {
        ReactEditor.focus(editor);
      }, 0);
    }
  }, []);
  useEffect(() => {
    setIsReady(false);
    setJsonVal(deserialize(autop(value)));
    setIsReady(true);
  }, [mergeTags?.length]);
  const TextEditor = useMemo(() => createElement(RichTextEditor, {
    value: jsonVal,
    editor: editor,
    onChange: onChange,
    mergeTags: mergeTags,
    onFocus: () => {
      if (editor.selection) {
        setCurrentSelection({
          path: editor.selection.focus.path,
          offset: editor.selection.focus.offset
        });
      }
    },
    allowedFormats: allowedFormats,
    placeholder: placeholder
  }), [isReady, JSON.stringify(jsonVal), JSON.stringify(mergeTags)]);
  if (!isReady) return null;
  return createElement("div", {
    className: classnames('rich-text-control', className)
  }, createElement(Fragment, null, TextEditor, mergeTags && mergeTags.length > 0 && createElement(Fragment, null, createElement("div", {
    className: "rich-text-control__add-merge-tags"
  }, createElement(Icon, {
    icon: plusCircle
    // @ts-expect-error
    ,
    onClick: e => {
      e.stopPropagation();
      Transforms.insertText(editor, '@', {
        at: currentSelection
      });
      setTimeout(() => {
        Transforms.select(editor, currentSelection);
        ReactEditor.focus(editor);
        Transforms.move(editor, {
          unit: 'character'
        });
      }, 0);
    }
  })))));
};
export default RichTextControlRenderer;
//# sourceMappingURL=renderer.js.map